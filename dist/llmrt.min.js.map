{"version":3,"file":"llmrt.min.js","sources":["../src/core/module-registry.ts","../src/core/input-manager.ts","../src/core/audio-manager.ts","../src/core/validator.ts","../src/core/asset-manager.ts","../src/core/cartridge-loader.ts","../src/core/accessibility-manager.ts","../src/core/engine.ts","../src/core/scene-tree.ts","../src/core/game-loop.ts","../src/modules/mode7.ts","../src/modules/particles.ts","../src/core/action-system.ts","../src/core/input-integration.ts","../src/core/renderer.ts","../src/core/trigger-system.ts","../src/index.ts"],"sourcesContent":["/**\n * Module registration system for tree-shakeable architecture\n */\n\nimport { ModuleDefinition, RenderModule } from '../types/modules.js';\nimport { ActionType, TriggerEvent } from '../types/actions.js';\n\nexport class ModuleRegistry {\n  private static instance: ModuleRegistry;\n  private modules = new Map<string, ModuleDefinition>();\n  private renderModules = new Map<string, RenderModule>();\n  private actionHandlers = new Map<ActionType, (params: any, context?: any) => void>();\n  private triggerEvents = new Set<TriggerEvent>();\n\n  static getInstance(): ModuleRegistry {\n    if (!ModuleRegistry.instance) {\n      ModuleRegistry.instance = new ModuleRegistry();\n    }\n    return ModuleRegistry.instance;\n  }\n\n  registerModule(module: ModuleDefinition): void {\n    this.modules.set(module.name, module);\n    \n    // Register node types\n    module.nodeTypes.forEach(_nodeType => {\n      // Node type registration will be handled by the scene tree system\n    });\n\n    // Register actions\n    module.actions.forEach(_action => {\n      // Action registration will be handled by the action system\n    });\n\n    // Register triggers\n    module.triggers.forEach(trigger => {\n      this.triggerEvents.add(trigger as TriggerEvent);\n    });\n  }\n\n  registerRenderModule(renderModule: RenderModule): void {\n    this.renderModules.set(renderModule.name, renderModule);\n  }\n\n  registerActionHandler(actionType: ActionType, handler: (params: any, context?: any) => void): void {\n    this.actionHandlers.set(actionType, handler);\n  }\n\n  getModule(name: string): ModuleDefinition | undefined {\n    return this.modules.get(name);\n  }\n\n  getRenderModule(name: string): RenderModule | undefined {\n    return this.renderModules.get(name);\n  }\n\n  getRenderModulesForNodeType(nodeType: string): RenderModule[] {\n    return Array.from(this.renderModules.values())\n      .filter(module => module.nodeTypes.includes(nodeType));\n  }\n\n  getActionHandler(actionType: ActionType): ((params: any, context?: any) => void) | undefined {\n    return this.actionHandlers.get(actionType);\n  }\n\n  isRegisteredModule(name: string): boolean {\n    return this.modules.has(name);\n  }\n\n  getRegisteredModules(): ModuleDefinition[] {\n    return Array.from(this.modules.values());\n  }\n\n  getRenderModules(): RenderModule[] {\n    return Array.from(this.renderModules.values());\n  }\n\n  getEstimatedSize(): number {\n    return Array.from(this.modules.values())\n      .reduce((total, module) => total + module.size, 0);\n  }\n\n  supportsNodeType(nodeType: string): boolean {\n    // Core node types are always supported\n    const coreNodeTypes = ['Group', 'Sprite', 'Text', 'Button', 'Camera2D', 'Particles2D', 'PostChain'];\n    if (coreNodeTypes.includes(nodeType)) {\n      return true;\n    }\n\n    // Check if any registered module supports this node type\n    return Array.from(this.modules.values())\n      .some(module => module.nodeTypes.includes(nodeType));\n  }\n\n  supportsTriggerEvent(event: TriggerEvent): boolean {\n    // Core trigger events are always supported\n    const coreTriggerEvents: TriggerEvent[] = ['on.start', 'on.tick', 'on.key', 'on.pointer', 'on.timer'];\n    if (coreTriggerEvents.includes(event)) {\n      return true;\n    }\n\n    // Check if any registered module supports this trigger event\n    return this.triggerEvents.has(event);\n  }\n}","/**\n * Input management system for the LLM Canvas Engine\n * Handles keyboard and pointer input with action mapping and state tracking\n */\n\nimport { Vector2 } from '../types/core.js';\n\nexport interface InputManager {\n  mapKey(key: string, action: string): void;\n  mapPointer(button: number, action: string): void;\n  isActionPressed(action: string): boolean;\n  isActionJustPressed(action: string): boolean;\n  isActionJustReleased(action: string): boolean;\n  getPointerPosition(): Vector2;\n  getPointerWorldPosition(camera?: any): Vector2;\n  initialize(canvas: HTMLCanvasElement): void;\n  cleanup(): void;\n  update(): void;\n}\n\ninterface InputState {\n  pressed: boolean;\n  justPressed: boolean;\n  justReleased: boolean;\n  framePressed: number;\n  frameReleased: number;\n}\n\ninterface PointerState {\n  position: Vector2;\n  worldPosition: Vector2;\n  buttons: Map<number, InputState>;\n}\n\nexport class InputManagerImpl implements InputManager {\n  private keyMappings = new Map<string, string>();\n  private pointerMappings = new Map<number, string>();\n  private actionStates = new Map<string, InputState>();\n  private keyStates = new Map<string, InputState>();\n  private pointerState: PointerState;\n  private canvas: HTMLCanvasElement | null = null;\n  private frameCount = 0;\n  private isInitialized = false;\n\n  // Event listeners for cleanup\n  private boundKeyDown: (e: KeyboardEvent) => void;\n  private boundKeyUp: (e: KeyboardEvent) => void;\n  private boundPointerDown: (e: PointerEvent) => void;\n  private boundPointerUp: (e: PointerEvent) => void;\n  private boundPointerMove: (e: PointerEvent) => void;\n  private boundContextMenu: (e: Event) => void;\n\n  constructor() {\n    this.pointerState = {\n      position: { x: 0, y: 0 },\n      worldPosition: { x: 0, y: 0 },\n      buttons: new Map()\n    };\n\n    // Bind event handlers for cleanup\n    this.boundKeyDown = this.handleKeyDown.bind(this);\n    this.boundKeyUp = this.handleKeyUp.bind(this);\n    this.boundPointerDown = this.handlePointerDown.bind(this);\n    this.boundPointerUp = this.handlePointerUp.bind(this);\n    this.boundPointerMove = this.handlePointerMove.bind(this);\n    this.boundContextMenu = this.handleContextMenu.bind(this);\n  }\n\n  initialize(canvas: HTMLCanvasElement): void {\n    if (this.isInitialized) {\n      this.cleanup();\n    }\n\n    this.canvas = canvas;\n    this.isInitialized = true;\n\n    // Add keyboard event listeners to document\n    document.addEventListener('keydown', this.boundKeyDown);\n    document.addEventListener('keyup', this.boundKeyUp);\n\n    // Add pointer event listeners to canvas\n    canvas.addEventListener('pointerdown', this.boundPointerDown);\n    canvas.addEventListener('pointerup', this.boundPointerUp);\n    canvas.addEventListener('pointermove', this.boundPointerMove);\n    canvas.addEventListener('contextmenu', this.boundContextMenu);\n\n    // Make canvas focusable for keyboard events\n    canvas.tabIndex = 0;\n    canvas.style.outline = 'none';\n  }\n\n  cleanup(): void {\n    if (!this.isInitialized) return;\n\n    // Remove event listeners\n    document.removeEventListener('keydown', this.boundKeyDown);\n    document.removeEventListener('keyup', this.boundKeyUp);\n\n    if (this.canvas) {\n      this.canvas.removeEventListener('pointerdown', this.boundPointerDown);\n      this.canvas.removeEventListener('pointerup', this.boundPointerUp);\n      this.canvas.removeEventListener('pointermove', this.boundPointerMove);\n      this.canvas.removeEventListener('contextmenu', this.boundContextMenu);\n    }\n\n    this.canvas = null;\n    this.isInitialized = false;\n  }\n\n  mapKey(key: string, action: string): void {\n    // Sanitize key input\n    const sanitizedKey = this.sanitizeKey(key);\n    const sanitizedAction = this.sanitizeAction(action);\n    \n    if (sanitizedKey && sanitizedAction) {\n      this.keyMappings.set(sanitizedKey, sanitizedAction);\n    }\n  }\n\n  mapPointer(button: number, action: string): void {\n    // Sanitize inputs\n    if (button < 0 || button > 4) return; // Only support standard mouse buttons\n    const sanitizedAction = this.sanitizeAction(action);\n    \n    if (sanitizedAction) {\n      this.pointerMappings.set(button, sanitizedAction);\n    }\n  }\n\n  isActionPressed(action: string): boolean {\n    const state = this.actionStates.get(action);\n    return state ? state.pressed : false;\n  }\n\n  isActionJustPressed(action: string): boolean {\n    const state = this.actionStates.get(action);\n    return state ? state.justPressed : false;\n  }\n\n  isActionJustReleased(action: string): boolean {\n    const state = this.actionStates.get(action);\n    return state ? state.justReleased : false;\n  }\n\n  getPointerPosition(): Vector2 {\n    return { ...this.pointerState.position };\n  }\n\n  getPointerWorldPosition(_camera?: any): Vector2 {\n    // For now, return screen position. Camera transformation would be added later\n    return { ...this.pointerState.position };\n  }\n\n  update(): void {\n    this.frameCount++;\n\n    // Update action states based on key and pointer states\n    this.updateActionStates();\n\n    // Clear just-pressed and just-released flags after one frame\n    this.clearFrameFlags();\n  }\n\n  private handleKeyDown(event: KeyboardEvent): void {\n    const key = this.normalizeKey(event.code);\n    if (!key) return;\n\n    // Prevent default for mapped keys to avoid browser shortcuts\n    const action = this.keyMappings.get(key);\n    if (action) {\n      event.preventDefault();\n    }\n\n    this.updateKeyState(key, true);\n  }\n\n  private handleKeyUp(event: KeyboardEvent): void {\n    const key = this.normalizeKey(event.code);\n    if (!key) return;\n\n    this.updateKeyState(key, false);\n  }\n\n  private handlePointerDown(event: PointerEvent): void {\n    if (!this.canvas) return;\n\n    event.preventDefault();\n    this.canvas.focus(); // Ensure canvas has focus for keyboard events\n\n    this.updatePointerPosition(event);\n    this.updatePointerButtonState(event.button, true);\n  }\n\n  private handlePointerUp(event: PointerEvent): void {\n    event.preventDefault();\n    this.updatePointerPosition(event);\n    this.updatePointerButtonState(event.button, false);\n  }\n\n  private handlePointerMove(event: PointerEvent): void {\n    this.updatePointerPosition(event);\n  }\n\n  private handleContextMenu(event: Event): void {\n    // Prevent context menu to avoid interfering with right-click actions\n    event.preventDefault();\n  }\n\n  private updatePointerPosition(event: PointerEvent): void {\n    if (!this.canvas) return;\n\n    const rect = this.canvas.getBoundingClientRect();\n    this.pointerState.position = {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }\n\n  private updateKeyState(key: string, pressed: boolean): void {\n    let state = this.keyStates.get(key);\n    if (!state) {\n      state = {\n        pressed: false,\n        justPressed: false,\n        justReleased: false,\n        framePressed: -1,\n        frameReleased: -1\n      };\n      this.keyStates.set(key, state);\n    }\n\n    if (pressed && !state.pressed) {\n      state.pressed = true;\n      state.justPressed = true;\n      state.framePressed = this.frameCount;\n    } else if (!pressed && state.pressed) {\n      state.pressed = false;\n      state.justReleased = true;\n      state.frameReleased = this.frameCount;\n    }\n  }\n\n  private updatePointerButtonState(button: number, pressed: boolean): void {\n    let state = this.pointerState.buttons.get(button);\n    if (!state) {\n      state = {\n        pressed: false,\n        justPressed: false,\n        justReleased: false,\n        framePressed: -1,\n        frameReleased: -1\n      };\n      this.pointerState.buttons.set(button, state);\n    }\n\n    if (pressed && !state.pressed) {\n      state.pressed = true;\n      state.justPressed = true;\n      state.framePressed = this.frameCount;\n    } else if (!pressed && state.pressed) {\n      state.pressed = false;\n      state.justReleased = true;\n      state.frameReleased = this.frameCount;\n    }\n  }\n\n  private updateActionStates(): void {\n    // Update action states based on key mappings\n    for (const [key, action] of this.keyMappings) {\n      const keyState = this.keyStates.get(key);\n      if (keyState) {\n        this.updateActionState(action, keyState);\n      }\n    }\n\n    // Update action states based on pointer mappings\n    for (const [button, action] of this.pointerMappings) {\n      const buttonState = this.pointerState.buttons.get(button);\n      if (buttonState) {\n        this.updateActionState(action, buttonState);\n      }\n    }\n  }\n\n  private updateActionState(action: string, inputState: InputState): void {\n    let actionState = this.actionStates.get(action);\n    if (!actionState) {\n      actionState = {\n        pressed: false,\n        justPressed: false,\n        justReleased: false,\n        framePressed: -1,\n        frameReleased: -1\n      };\n      this.actionStates.set(action, actionState);\n    }\n\n    // Action is pressed if any mapped input is pressed\n    if (inputState.pressed) {\n      if (!actionState.pressed) {\n        actionState.pressed = true;\n        actionState.justPressed = true;\n        actionState.framePressed = this.frameCount;\n      }\n    }\n\n    // Action is released when all mapped inputs are released\n    if (!inputState.pressed && actionState.pressed) {\n      // Check if any other inputs for this action are still pressed\n      let anyPressed = false;\n      \n      for (const [key, mappedAction] of this.keyMappings) {\n        if (mappedAction === action) {\n          const keyState = this.keyStates.get(key);\n          if (keyState && keyState.pressed) {\n            anyPressed = true;\n            break;\n          }\n        }\n      }\n\n      if (!anyPressed) {\n        for (const [button, mappedAction] of this.pointerMappings) {\n          if (mappedAction === action) {\n            const buttonState = this.pointerState.buttons.get(button);\n            if (buttonState && buttonState.pressed) {\n              anyPressed = true;\n              break;\n            }\n          }\n        }\n      }\n\n      if (!anyPressed) {\n        actionState.pressed = false;\n        actionState.justReleased = true;\n        actionState.frameReleased = this.frameCount;\n      }\n    }\n  }\n\n  private clearFrameFlags(): void {\n    // Clear just-pressed and just-released flags for keys\n    for (const state of this.keyStates.values()) {\n      if (state.justPressed && state.framePressed < this.frameCount) {\n        state.justPressed = false;\n      }\n      if (state.justReleased && state.frameReleased < this.frameCount) {\n        state.justReleased = false;\n      }\n    }\n\n    // Clear just-pressed and just-released flags for pointer buttons\n    for (const state of this.pointerState.buttons.values()) {\n      if (state.justPressed && state.framePressed < this.frameCount) {\n        state.justPressed = false;\n      }\n      if (state.justReleased && state.frameReleased < this.frameCount) {\n        state.justReleased = false;\n      }\n    }\n\n    // Clear just-pressed and just-released flags for actions\n    for (const state of this.actionStates.values()) {\n      if (state.justPressed && state.framePressed < this.frameCount) {\n        state.justPressed = false;\n      }\n      if (state.justReleased && state.frameReleased < this.frameCount) {\n        state.justReleased = false;\n      }\n    }\n  }\n\n  private normalizeKey(code: string): string | null {\n    // Normalize key codes to consistent format\n    // Remove common prefixes and convert to lowercase\n    const normalized = code\n      .replace(/^(Key|Digit|Numpad|Arrow)/, '')\n      .toLowerCase();\n\n    // Map some special cases for accessibility\n    const keyMap: Record<string, string> = {\n      'space': 'space',\n      'enter': 'enter',\n      'escape': 'escape',\n      'tab': 'tab',\n      'backspace': 'backspace',\n      'delete': 'delete',\n      'home': 'home',\n      'end': 'end',\n      'pageup': 'pageup',\n      'pagedown': 'pagedown',\n      'up': 'up',\n      'down': 'down',\n      'left': 'left',\n      'right': 'right'\n    };\n\n    return keyMap[normalized] || normalized;\n  }\n\n  private sanitizeKey(key: string): string | null {\n    // Only allow alphanumeric keys and common special keys\n    const allowedPattern = /^[a-z0-9]$|^(space|enter|escape|tab|backspace|delete|home|end|pageup|pagedown|up|down|left|right|shift|ctrl|alt|meta)$/i;\n    \n    const normalized = key.toLowerCase().trim();\n    return allowedPattern.test(normalized) ? normalized : null;\n  }\n\n  private sanitizeAction(action: string): string | null {\n    // Only allow alphanumeric characters, underscores, and hyphens\n    const allowedPattern = /^[a-zA-Z0-9_-]+$/;\n    \n    const trimmed = action.trim();\n    return allowedPattern.test(trimmed) && trimmed.length <= 50 ? trimmed : null;\n  }\n}","/**\n * Lightweight audio system for the LLM Canvas Engine\n * Handles SFX and music playback with mobile audio unlock support\n */\n\nimport { AudioManager as IAudioManager, AudioAsset } from '../types/core.js';\n\ninterface LoadedAudioAsset {\n  id: string;\n  audio: HTMLAudioElement;\n  type: 'sfx' | 'music';\n}\n\nexport class AudioManager implements IAudioManager {\n  private assets: Map<string, LoadedAudioAsset> = new Map();\n  private currentMusic: HTMLAudioElement | null = null;\n  private masterVolume: number = 1.0;\n  private unlocked: boolean = false;\n  private unlockPromise: Promise<void> | null = null;\n\n  constructor() {\n    // Bind methods to preserve context\n    this.handleUserInteraction = this.handleUserInteraction.bind(this);\n    \n    // Set up auto-unlock on first user interaction\n    this.setupAutoUnlock();\n  }\n\n  /**\n   * Play a sound effect\n   */\n  playSfx(id: string, volume: number = 1.0): void {\n    const asset = this.assets.get(id);\n    if (!asset || asset.type !== 'sfx') {\n      console.warn(`SFX asset '${id}' not found`);\n      return;\n    }\n\n    // Clone the audio element for overlapping playback\n    const audio = asset.audio.cloneNode() as HTMLAudioElement;\n    audio.volume = Math.max(0, Math.min(1, volume * this.masterVolume));\n    \n    // Clean up after playback\n    audio.addEventListener('ended', () => {\n      audio.remove();\n    });\n\n    // Play if unlocked, otherwise queue for unlock\n    if (this.unlocked) {\n      const playPromise = audio.play();\n      if (playPromise && typeof playPromise.catch === 'function') {\n        playPromise.catch(error => {\n          console.warn(`Failed to play SFX '${id}':`, error);\n        });\n      }\n    } else {\n      this.unlock().then(() => {\n        const playPromise = audio.play();\n        if (playPromise && typeof playPromise.catch === 'function') {\n          playPromise.catch(error => {\n            console.warn(`Failed to play SFX '${id}':`, error);\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Play background music\n   */\n  playMusic(id: string, loop: boolean = true, volume: number = 1.0): void {\n    const asset = this.assets.get(id);\n    if (!asset || asset.type !== 'music') {\n      console.warn(`Music asset '${id}' not found`);\n      return;\n    }\n\n    // Stop current music if playing\n    this.stopMusic();\n\n    // Set up new music\n    this.currentMusic = asset.audio.cloneNode() as HTMLAudioElement;\n    this.currentMusic.loop = loop;\n    this.currentMusic.volume = Math.max(0, Math.min(1, volume * this.masterVolume));\n\n    // Play if unlocked, otherwise queue for unlock\n    if (this.unlocked) {\n      const playPromise = this.currentMusic.play();\n      if (playPromise && typeof playPromise.catch === 'function') {\n        playPromise.catch(error => {\n          console.warn(`Failed to play music '${id}':`, error);\n        });\n      }\n    } else {\n      this.unlock().then(() => {\n        if (this.currentMusic) {\n          const playPromise = this.currentMusic.play();\n          if (playPromise && typeof playPromise.catch === 'function') {\n            playPromise.catch(error => {\n              console.warn(`Failed to play music '${id}':`, error);\n            });\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Stop currently playing music\n   */\n  stopMusic(): void {\n    if (this.currentMusic) {\n      this.currentMusic.pause();\n      this.currentMusic.currentTime = 0;\n      this.currentMusic = null;\n    }\n  }\n\n  /**\n   * Set master volume for all audio\n   */\n  setMasterVolume(volume: number): void {\n    this.masterVolume = Math.max(0, Math.min(1, volume));\n    \n    // Update current music volume\n    if (this.currentMusic) {\n      this.currentMusic.volume = this.currentMusic.volume * this.masterVolume;\n    }\n  }\n\n  /**\n   * Load audio assets and cache them\n   */\n  async loadAssets(assets: AudioAsset[]): Promise<void> {\n    const loadPromises = assets.map(asset => this.loadAsset(asset));\n    await Promise.all(loadPromises);\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup(): void {\n    this.stopMusic();\n    this.assets.clear();\n    this.removeAutoUnlock();\n  }\n\n  /**\n   * Check if audio is unlocked (required for mobile)\n   */\n  isUnlocked(): boolean {\n    return this.unlocked;\n  }\n\n  /**\n   * Manually unlock audio (usually called on user interaction)\n   */\n  async unlock(): Promise<void> {\n    if (this.unlocked) {\n      return;\n    }\n\n    if (this.unlockPromise) {\n      return this.unlockPromise;\n    }\n\n    this.unlockPromise = this.performUnlock();\n    return this.unlockPromise;\n  }\n\n  /**\n   * Load a single audio asset\n   */\n  private async loadAsset(asset: AudioAsset): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const audio = new Audio();\n      \n      audio.addEventListener('canplaythrough', () => {\n        this.assets.set(asset.id, {\n          id: asset.id,\n          audio,\n          type: asset.type\n        });\n        resolve();\n      });\n\n      audio.addEventListener('error', (error) => {\n        console.warn(`Failed to load audio asset '${asset.id}':`, error);\n        reject(error);\n      });\n\n      // Set up audio element\n      audio.preload = 'auto';\n      audio.src = asset.url;\n    });\n  }\n\n  /**\n   * Set up automatic audio unlock on first user interaction\n   */\n  private setupAutoUnlock(): void {\n    // Listen for various user interaction events\n    const events = ['click', 'touchstart', 'keydown'];\n    events.forEach(event => {\n      document.addEventListener(event, this.handleUserInteraction, { once: true, passive: true });\n    });\n  }\n\n  /**\n   * Remove auto-unlock event listeners\n   */\n  private removeAutoUnlock(): void {\n    const events = ['click', 'touchstart', 'keydown'];\n    events.forEach(event => {\n      document.removeEventListener(event, this.handleUserInteraction);\n    });\n  }\n\n  /**\n   * Handle user interaction for audio unlock\n   */\n  private handleUserInteraction(): void {\n    this.unlock();\n  }\n\n  /**\n   * Perform the actual audio unlock\n   */\n  private async performUnlock(): Promise<void> {\n    try {\n      // Create a silent audio element and try to play it\n      const silentAudio = new Audio();\n      silentAudio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmHgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';\n      silentAudio.volume = 0;\n      \n      await silentAudio.play();\n      \n      this.unlocked = true;\n      this.removeAutoUnlock();\n      \n      console.log('Audio unlocked successfully');\n    } catch (error) {\n      console.warn('Failed to unlock audio:', error);\n      // Still mark as unlocked to avoid repeated attempts\n      this.unlocked = true;\n    } finally {\n      this.unlockPromise = null;\n    }\n  }\n}","/**\n * LGF Cartridge Validation System\n * Provides schema validation with actionable error messages\n */\n\nimport { LGFCartridge } from '../types/core.js';\n\nexport interface ValidationError {\n  path: string;\n  message: string;\n  suggestion?: string;\n  code: string;\n}\n\nexport interface ValidationWarning {\n  path: string;\n  message: string;\n  suggestion?: string;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n}\n\n/**\n * Simple JSON Schema validator implementation\n * Focused on LGF schema validation with actionable error messages\n */\nexport class LGFValidator {\n  constructor() {\n    // Custom validator implementation - doesn't need schema object\n  }\n\n  /**\n   * Validate a cartridge against the LGF schema\n   */\n  validate(cartridge: any): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    try {\n      // Basic structure validation\n      this.validateStructure(cartridge, '', errors);\n      \n      // Semantic validation\n      if (errors.length === 0) {\n        this.validateSemantics(cartridge, warnings);\n      }\n\n      return {\n        valid: errors.length === 0,\n        errors,\n        warnings\n      };\n    } catch (error) {\n      errors.push({\n        path: '',\n        message: `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        code: 'VALIDATION_ERROR'\n      });\n\n      return {\n        valid: false,\n        errors,\n        warnings\n      };\n    }\n  }\n\n  private validateStructure(obj: any, path: string, errors: ValidationError[]): void {\n    // Root level validation\n    if (path === '') {\n      if (typeof obj !== 'object' || obj === null) {\n        errors.push({\n          path: '',\n          message: 'Cartridge must be a JSON object',\n          suggestion: 'Ensure your cartridge is a valid JSON object with required properties',\n          code: 'INVALID_ROOT_TYPE'\n        });\n        return;\n      }\n\n      // Check required root properties\n      const requiredProps = ['version', 'metadata', 'theme', 'scenes', 'assets'];\n      for (const prop of requiredProps) {\n        if (!(prop in obj)) {\n          errors.push({\n            path: prop,\n            message: `Missing required property: ${prop}`,\n            suggestion: `Add the \"${prop}\" property to your cartridge`,\n            code: 'MISSING_REQUIRED_PROPERTY'\n          });\n        }\n      }\n\n      // Check for unknown properties\n      const allowedProps = [...requiredProps, 'variables'];\n      for (const prop in obj) {\n        if (!allowedProps.includes(prop)) {\n          errors.push({\n            path: prop,\n            message: `Unknown property: ${prop}`,\n            suggestion: `Remove \"${prop}\" or check for typos. Allowed properties: ${allowedProps.join(', ')}`,\n            code: 'UNKNOWN_PROPERTY'\n          });\n        }\n      }\n\n      // Validate each property if present\n      if (obj.version !== undefined) {\n        this.validateStructure(obj.version, 'version', errors);\n      }\n      if (obj.metadata !== undefined) {\n        this.validateStructure(obj.metadata, 'metadata', errors);\n      }\n      if (obj.theme !== undefined) {\n        this.validateStructure(obj.theme, 'theme', errors);\n      }\n      if (obj.scenes !== undefined) {\n        this.validateStructure(obj.scenes, 'scenes', errors);\n      }\n      if (obj.assets !== undefined) {\n        this.validateStructure(obj.assets, 'assets', errors);\n      }\n      if (obj.variables !== undefined) {\n        this.validateStructure(obj.variables, 'variables', errors);\n      }\n      return;\n    }\n\n    // Version validation\n    if (path === 'version') {\n      if (obj !== '1.0') {\n        errors.push({\n          path: 'version',\n          message: `Invalid version: ${obj}`,\n          suggestion: 'Use version \"1.0\"',\n          code: 'INVALID_VERSION'\n        });\n      }\n      return;\n    }\n\n    // Metadata validation\n    if (path === 'metadata') {\n      this.validateMetadata(obj, errors);\n      return;\n    }\n\n    // Theme validation\n    if (path === 'theme') {\n      this.validateTheme(obj, errors);\n      return;\n    }\n\n    // Scenes validation\n    if (path === 'scenes') {\n      this.validateScenes(obj, errors);\n      return;\n    }\n\n    // Assets validation\n    if (path === 'assets') {\n      this.validateAssets(obj, errors);\n      return;\n    }\n\n    // Variables validation\n    if (path === 'variables') {\n      this.validateVariables(obj, errors);\n      return;\n    }\n  }\n\n  private validateMetadata(metadata: any, errors: ValidationError[]): void {\n    if (typeof metadata !== 'object' || metadata === null) {\n      errors.push({\n        path: 'metadata',\n        message: 'Metadata must be an object',\n        suggestion: 'Provide metadata with title, author, and description',\n        code: 'INVALID_METADATA_TYPE'\n      });\n      return;\n    }\n\n    const requiredFields = ['title', 'author', 'description'];\n    for (const field of requiredFields) {\n      if (!(field in metadata)) {\n        errors.push({\n          path: `metadata.${field}`,\n          message: `Missing required metadata field: ${field}`,\n          suggestion: `Add \"${field}\" to your metadata`,\n          code: 'MISSING_METADATA_FIELD'\n        });\n      } else if (typeof metadata[field] !== 'string' || metadata[field].length === 0) {\n        errors.push({\n          path: `metadata.${field}`,\n          message: `Metadata ${field} must be a non-empty string`,\n          suggestion: `Provide a valid ${field} string`,\n          code: 'INVALID_METADATA_VALUE'\n        });\n      }\n    }\n  }\n\n  private validateTheme(theme: any, errors: ValidationError[]): void {\n    if (typeof theme !== 'object' || theme === null) {\n      errors.push({\n        path: 'theme',\n        message: 'Theme must be an object',\n        suggestion: 'Provide theme with colors, font, spacing, and radii',\n        code: 'INVALID_THEME_TYPE'\n      });\n      return;\n    }\n\n    // Validate colors\n    if (!theme.colors || typeof theme.colors !== 'object') {\n      errors.push({\n        path: 'theme.colors',\n        message: 'Theme colors must be an object',\n        suggestion: 'Provide colors object with primary, secondary, background, text, and accent',\n        code: 'INVALID_THEME_COLORS'\n      });\n    } else {\n      const requiredColors = ['primary', 'secondary', 'background', 'text', 'accent'];\n      for (const color of requiredColors) {\n        if (!(color in theme.colors)) {\n          errors.push({\n            path: `theme.colors.${color}`,\n            message: `Missing required color: ${color}`,\n            suggestion: `Add \"${color}\" color to your theme`,\n            code: 'MISSING_THEME_COLOR'\n          });\n        } else if (!this.isValidColor(theme.colors[color])) {\n          errors.push({\n            path: `theme.colors.${color}`,\n            message: `Invalid color format: ${theme.colors[color]}`,\n            suggestion: 'Use hex color format like #FF0000 or #F00',\n            code: 'INVALID_COLOR_FORMAT'\n          });\n        }\n      }\n    }\n\n    // Validate font\n    if (!theme.font || typeof theme.font !== 'object') {\n      errors.push({\n        path: 'theme.font',\n        message: 'Theme font must be an object',\n        suggestion: 'Provide font object with family and sizes',\n        code: 'INVALID_THEME_FONT'\n      });\n    }\n\n    // Validate spacing and radii\n    ['spacing', 'radii'].forEach(prop => {\n      if (!theme[prop] || typeof theme[prop] !== 'object') {\n        errors.push({\n          path: `theme.${prop}`,\n          message: `Theme ${prop} must be an object`,\n          suggestion: `Provide ${prop} object with numeric values`,\n          code: 'INVALID_THEME_PROPERTY'\n        });\n      }\n    });\n  }\n\n  private validateScenes(scenes: any, errors: ValidationError[]): void {\n    if (!Array.isArray(scenes)) {\n      errors.push({\n        path: 'scenes',\n        message: 'Scenes must be an array',\n        suggestion: 'Provide an array of scene objects',\n        code: 'INVALID_SCENES_TYPE'\n      });\n      return;\n    }\n\n    if (scenes.length === 0) {\n      errors.push({\n        path: 'scenes',\n        message: 'At least one scene is required',\n        suggestion: 'Add at least one scene to your cartridge',\n        code: 'NO_SCENES'\n      });\n      return;\n    }\n\n    const sceneIds = new Set<string>();\n    scenes.forEach((scene, index) => {\n      if (typeof scene !== 'object' || scene === null) {\n        errors.push({\n          path: `scenes[${index}]`,\n          message: 'Scene must be an object',\n          suggestion: 'Provide scene object with id and root node',\n          code: 'INVALID_SCENE_TYPE'\n        });\n        return;\n      }\n\n      if (!scene.id || typeof scene.id !== 'string') {\n        errors.push({\n          path: `scenes[${index}].id`,\n          message: 'Scene id must be a non-empty string',\n          suggestion: 'Provide a unique scene identifier',\n          code: 'INVALID_SCENE_ID'\n        });\n      } else {\n        if (sceneIds.has(scene.id)) {\n          errors.push({\n            path: `scenes[${index}].id`,\n            message: `Duplicate scene id: ${scene.id}`,\n            suggestion: 'Use unique scene identifiers',\n            code: 'DUPLICATE_SCENE_ID'\n          });\n        }\n        sceneIds.add(scene.id);\n\n        if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(scene.id)) {\n          errors.push({\n            path: `scenes[${index}].id`,\n            message: `Invalid scene id format: ${scene.id}`,\n            suggestion: 'Scene ids must start with a letter and contain only letters, numbers, underscores, and hyphens',\n            code: 'INVALID_ID_FORMAT'\n          });\n        }\n      }\n\n      if (!scene.root) {\n        errors.push({\n          path: `scenes[${index}].root`,\n          message: 'Scene must have a root node',\n          suggestion: 'Provide a root node for the scene',\n          code: 'MISSING_SCENE_ROOT'\n        });\n      } else {\n        this.validateNode(scene.root, `scenes[${index}].root`, errors);\n      }\n    });\n  }\n\n  private validateNode(node: any, path: string, errors: ValidationError[]): void {\n    if (typeof node !== 'object' || node === null) {\n      errors.push({\n        path,\n        message: 'Node must be an object',\n        suggestion: 'Provide node object with required properties',\n        code: 'INVALID_NODE_TYPE'\n      });\n      return;\n    }\n\n    // Validate required properties\n    const requiredProps = ['id', 'type', 'transform', 'visible', 'children', 'actions', 'triggers'];\n    for (const prop of requiredProps) {\n      if (!(prop in node)) {\n        errors.push({\n          path: `${path}.${prop}`,\n          message: `Missing required node property: ${prop}`,\n          suggestion: `Add \"${prop}\" to your node`,\n          code: 'MISSING_NODE_PROPERTY'\n        });\n      }\n    }\n\n    // Validate node id\n    if (node.id && (typeof node.id !== 'string' || !/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(node.id))) {\n      errors.push({\n        path: `${path}.id`,\n        message: `Invalid node id format: ${node.id}`,\n        suggestion: 'Node ids must start with a letter and contain only letters, numbers, underscores, and hyphens',\n        code: 'INVALID_NODE_ID'\n      });\n    }\n\n    // Validate node type\n    const validNodeTypes = [\n      'Group', 'Sprite', 'Text', 'Button', 'Camera2D', \n      'Particles2D', 'PostChain', 'Mode7Plane', 'RaycastMap', 'TilemapIso'\n    ];\n    if (node.type && !validNodeTypes.includes(node.type)) {\n      errors.push({\n        path: `${path}.type`,\n        message: `Invalid node type: ${node.type}`,\n        suggestion: `Use one of: ${validNodeTypes.join(', ')}`,\n        code: 'INVALID_NODE_TYPE_VALUE'\n      });\n    }\n\n    // Validate transform\n    if (node.transform) {\n      this.validateTransform(node.transform, `${path}.transform`, errors);\n    }\n\n    // Validate children\n    if (node.children && Array.isArray(node.children)) {\n      node.children.forEach((child: any, index: number) => {\n        this.validateNode(child, `${path}.children[${index}]`, errors);\n      });\n    }\n\n    // Validate actions\n    if (node.actions && Array.isArray(node.actions)) {\n      node.actions.forEach((action: any, index: number) => {\n        this.validateAction(action, `${path}.actions[${index}]`, errors);\n      });\n    }\n\n    // Validate triggers\n    if (node.triggers && Array.isArray(node.triggers)) {\n      node.triggers.forEach((trigger: any, index: number) => {\n        this.validateTrigger(trigger, `${path}.triggers[${index}]`, errors);\n      });\n    }\n  }\n\n  private validateTransform(transform: any, path: string, errors: ValidationError[]): void {\n    if (typeof transform !== 'object' || transform === null) {\n      errors.push({\n        path,\n        message: 'Transform must be an object',\n        suggestion: 'Provide transform with position, scale, rotation, skew, and alpha',\n        code: 'INVALID_TRANSFORM_TYPE'\n      });\n      return;\n    }\n\n    const requiredProps = ['position', 'scale', 'rotation', 'skew', 'alpha'];\n    for (const prop of requiredProps) {\n      if (!(prop in transform)) {\n        errors.push({\n          path: `${path}.${prop}`,\n          message: `Missing required transform property: ${prop}`,\n          suggestion: `Add \"${prop}\" to your transform`,\n          code: 'MISSING_TRANSFORM_PROPERTY'\n        });\n      }\n    }\n\n    // Validate Vector2 properties\n    ['position', 'scale', 'skew'].forEach(prop => {\n      if (transform[prop]) {\n        this.validateVector2(transform[prop], `${path}.${prop}`, errors);\n      }\n    });\n\n    // Validate numeric properties\n    if (transform.rotation !== undefined && typeof transform.rotation !== 'number') {\n      errors.push({\n        path: `${path}.rotation`,\n        message: 'Transform rotation must be a number',\n        suggestion: 'Provide rotation as a numeric value in radians',\n        code: 'INVALID_ROTATION_TYPE'\n      });\n    }\n\n    if (transform.alpha !== undefined) {\n      if (typeof transform.alpha !== 'number' || transform.alpha < 0 || transform.alpha > 1) {\n        errors.push({\n          path: `${path}.alpha`,\n          message: 'Transform alpha must be a number between 0 and 1',\n          suggestion: 'Provide alpha as a numeric value between 0 (transparent) and 1 (opaque)',\n          code: 'INVALID_ALPHA_VALUE'\n        });\n      }\n    }\n  }\n\n  private validateVector2(vector: any, path: string, errors: ValidationError[]): void {\n    // Support both array format [x, y] and object format {x, y}\n    if (Array.isArray(vector)) {\n      if (vector.length !== 2) {\n        errors.push({\n          path,\n          message: 'Vector2 array must have exactly 2 elements',\n          suggestion: 'Provide vector as [x, y] with two numeric values',\n          code: 'INVALID_VECTOR2_ARRAY_LENGTH'\n        });\n        return;\n      }\n      \n      vector.forEach((value, index) => {\n        if (typeof value !== 'number') {\n          errors.push({\n            path: `${path}[${index}]`,\n            message: `Vector2 array element must be a number`,\n            suggestion: `Provide numeric value at index ${index}`,\n            code: 'INVALID_VECTOR2_ARRAY_VALUE'\n          });\n        }\n      });\n      return;\n    }\n\n    if (typeof vector !== 'object' || vector === null) {\n      errors.push({\n        path,\n        message: 'Vector2 must be an array [x, y] or object {x, y}',\n        suggestion: 'Provide vector as [x, y] array or {x, y} object with numeric values',\n        code: 'INVALID_VECTOR2_TYPE'\n      });\n      return;\n    }\n\n    ['x', 'y'].forEach(prop => {\n      if (!(prop in vector)) {\n        errors.push({\n          path: `${path}.${prop}`,\n          message: `Missing required vector property: ${prop}`,\n          suggestion: `Add \"${prop}\" numeric value to your vector`,\n          code: 'MISSING_VECTOR_PROPERTY'\n        });\n      } else if (typeof vector[prop] !== 'number') {\n        errors.push({\n          path: `${path}.${prop}`,\n          message: `Vector ${prop} must be a number`,\n          suggestion: `Provide ${prop} as a numeric value`,\n          code: 'INVALID_VECTOR_VALUE'\n        });\n      }\n    });\n  }\n\n  private validateAction(action: any, path: string, errors: ValidationError[]): void {\n    if (typeof action !== 'object' || action === null) {\n      errors.push({\n        path,\n        message: 'Action must be an object',\n        suggestion: 'Provide action with type and params',\n        code: 'INVALID_ACTION_TYPE'\n      });\n      return;\n    }\n\n    const validActionTypes = [\n      'gotoScene', 'spawn', 'despawn', 'setVar', 'incVar', 'randomInt',\n      'if', 'tween', 'playSprite', 'setCamera', 'shake', 'playSfx',\n      'playMusic', 'startTimer', 'stopTimer', 'emit', 'moveCamera'\n    ];\n\n    if (!action.type) {\n      errors.push({\n        path: `${path}.type`,\n        message: 'Action must have a type',\n        suggestion: `Use one of: ${validActionTypes.join(', ')}`,\n        code: 'MISSING_ACTION_TYPE'\n      });\n    } else if (!validActionTypes.includes(action.type)) {\n      errors.push({\n        path: `${path}.type`,\n        message: `Invalid action type: ${action.type}`,\n        suggestion: `Use one of: ${validActionTypes.join(', ')}`,\n        code: 'INVALID_ACTION_TYPE_VALUE'\n      });\n    }\n\n    if (!action.params || typeof action.params !== 'object') {\n      errors.push({\n        path: `${path}.params`,\n        message: 'Action must have params object',\n        suggestion: 'Provide params object with action-specific parameters',\n        code: 'MISSING_ACTION_PARAMS'\n      });\n    }\n  }\n\n  private validateTrigger(trigger: any, path: string, errors: ValidationError[]): void {\n    if (typeof trigger !== 'object' || trigger === null) {\n      errors.push({\n        path,\n        message: 'Trigger must be an object',\n        suggestion: 'Provide trigger with event and actions',\n        code: 'INVALID_TRIGGER_TYPE'\n      });\n      return;\n    }\n\n    const validTriggerEvents = [\n      'on.start', 'on.tick', 'on.key', 'on.pointer', \n      'on.timer', 'on.raycastHit'\n    ];\n\n    if (!trigger.event) {\n      errors.push({\n        path: `${path}.event`,\n        message: 'Trigger must have an event',\n        suggestion: `Use one of: ${validTriggerEvents.join(', ')}`,\n        code: 'MISSING_TRIGGER_EVENT'\n      });\n    } else if (!validTriggerEvents.includes(trigger.event)) {\n      errors.push({\n        path: `${path}.event`,\n        message: `Invalid trigger event: ${trigger.event}`,\n        suggestion: `Use one of: ${validTriggerEvents.join(', ')}`,\n        code: 'INVALID_TRIGGER_EVENT'\n      });\n    }\n\n    if (!trigger.actions || !Array.isArray(trigger.actions)) {\n      errors.push({\n        path: `${path}.actions`,\n        message: 'Trigger must have actions array',\n        suggestion: 'Provide array of actions to execute when trigger fires',\n        code: 'MISSING_TRIGGER_ACTIONS'\n      });\n    } else {\n      trigger.actions.forEach((action: any, index: number) => {\n        this.validateAction(action, `${path}.actions[${index}]`, errors);\n      });\n    }\n  }\n\n  private validateAssets(assets: any, errors: ValidationError[]): void {\n    if (typeof assets !== 'object' || assets === null) {\n      errors.push({\n        path: 'assets',\n        message: 'Assets must be an object',\n        suggestion: 'Provide assets with sprites, audio, and fonts arrays',\n        code: 'INVALID_ASSETS_TYPE'\n      });\n      return;\n    }\n\n    ['sprites', 'audio', 'fonts'].forEach(assetType => {\n      if (!(assetType in assets)) {\n        errors.push({\n          path: `assets.${assetType}`,\n          message: `Missing required asset type: ${assetType}`,\n          suggestion: `Add \"${assetType}\" array to your assets`,\n          code: 'MISSING_ASSET_TYPE'\n        });\n      } else if (!Array.isArray(assets[assetType])) {\n        errors.push({\n          path: `assets.${assetType}`,\n          message: `Assets ${assetType} must be an array`,\n          suggestion: `Provide ${assetType} as an array of asset objects`,\n          code: 'INVALID_ASSET_TYPE_FORMAT'\n        });\n      }\n    });\n  }\n\n  private validateVariables(variables: any, errors: ValidationError[]): void {\n    if (typeof variables !== 'object' || variables === null) {\n      errors.push({\n        path: 'variables',\n        message: 'Variables must be an object',\n        suggestion: 'Provide variables as an object with string keys and number/string/boolean values',\n        code: 'INVALID_VARIABLES_TYPE'\n      });\n      return;\n    }\n\n    for (const [key, value] of Object.entries(variables)) {\n      const validTypes = ['number', 'string', 'boolean'];\n      if (!validTypes.includes(typeof value)) {\n        errors.push({\n          path: `variables.${key}`,\n          message: `Variable ${key} has invalid type: ${typeof value}`,\n          suggestion: 'Variables must be numbers, strings, or booleans',\n          code: 'INVALID_VARIABLE_TYPE'\n        });\n      }\n    }\n  }\n\n  private validateSemantics(cartridge: LGFCartridge, warnings: ValidationWarning[]): void {\n    // Check for common issues that don't break validation but might cause problems\n\n    // Check for empty scenes\n    cartridge.scenes.forEach((scene, index) => {\n      if (!scene.root.children || scene.root.children.length === 0) {\n        warnings.push({\n          path: `scenes[${index}]`,\n          message: `Scene \"${scene.id}\" has no child nodes`,\n          suggestion: 'Consider adding some content to make the scene interactive'\n        });\n      }\n    });\n\n    // TODO: Check for unused assets in future implementation\n    // This would require analyzing node properties to find asset references\n\n    // Check for performance concerns\n    const totalSprites = cartridge.assets.sprites.length;\n    if (totalSprites > 100) {\n      warnings.push({\n        path: 'assets.sprites',\n        message: `Large number of sprites (${totalSprites})`,\n        suggestion: 'Consider optimizing sprite usage for better performance'\n      });\n    }\n  }\n\n  private isValidColor(color: string): boolean {\n    return typeof color === 'string' && /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$/.test(color);\n  }\n}\n\n/**\n * Convenience function to validate a cartridge\n */\nexport function validateCartridge(cartridge: any): ValidationResult {\n  const validator = new LGFValidator();\n  return validator.validate(cartridge);\n}","/**\n * Asset Management System\n * Handles loading, caching, and management of sprites, audio, and fonts\n */\n\nimport { SpriteAsset, FontAsset, AssetManifest } from '../types/core.js';\n\nexport interface LoadedSpriteAsset {\n  id: string;\n  image: HTMLImageElement;\n  width: number;\n  height: number;\n  frames: number;\n}\n\nexport interface LoadedFontAsset {\n  id: string;\n  family: string;\n  loaded: boolean;\n}\n\nexport interface AssetLoadProgress {\n  total: number;\n  loaded: number;\n  failed: number;\n  progress: number; // 0-1\n  currentAsset?: string;\n}\n\nexport interface AssetLoadOptions {\n  onProgress?: (progress: AssetLoadProgress) => void;\n  timeout?: number; // milliseconds\n  retryCount?: number;\n}\n\nexport class AssetManager {\n  private sprites: Map<string, LoadedSpriteAsset> = new Map();\n  private fonts: Map<string, LoadedFontAsset> = new Map();\n  private loadingPromises: Map<string, Promise<any>> = new Map();\n  \n  // Default/fallback assets\n  private defaultSprite: HTMLImageElement | null = null;\n  private defaultFont: string = 'Arial, sans-serif';\n\n  constructor() {\n    this.createDefaultAssets();\n  }\n\n  /**\n   * Load all assets from a manifest\n   */\n  async loadAssets(manifest: AssetManifest, options: AssetLoadOptions = {}): Promise<void> {\n    const { onProgress, timeout = 10000, retryCount = 2 } = options;\n    \n    const allAssets = [\n      ...manifest.sprites.map(asset => ({ ...asset, type: 'sprite' as const })),\n      ...manifest.fonts.map(asset => ({ ...asset, type: 'font' as const }))\n    ];\n\n    const progress: AssetLoadProgress = {\n      total: allAssets.length,\n      loaded: 0,\n      failed: 0,\n      progress: 0\n    };\n\n    if (onProgress) {\n      onProgress(progress);\n    }\n\n    const loadPromises = allAssets.map(async (asset) => {\n      try {\n        progress.currentAsset = asset.id;\n        \n        if (asset.type === 'sprite') {\n          await this.loadSpriteAsset(asset as SpriteAsset, timeout, retryCount);\n        } else if (asset.type === 'font') {\n          await this.loadFontAsset(asset as FontAsset, timeout, retryCount);\n        }\n        \n        progress.loaded++;\n      } catch (error) {\n        console.warn(`Failed to load asset '${asset.id}':`, error);\n        progress.failed++;\n      }\n      \n      progress.progress = (progress.loaded + progress.failed) / progress.total;\n      if (onProgress) {\n        onProgress(progress);\n      }\n    });\n\n    await Promise.allSettled(loadPromises);\n  }\n\n  /**\n   * Load a single sprite asset\n   */\n  async loadSpriteAsset(asset: SpriteAsset, timeout: number = 10000, retryCount: number = 2): Promise<LoadedSpriteAsset> {\n    // Check if already loaded\n    const existing = this.sprites.get(asset.id);\n    if (existing) {\n      return existing;\n    }\n\n    // Check if already loading\n    const existingPromise = this.loadingPromises.get(`sprite:${asset.id}`);\n    if (existingPromise) {\n      return existingPromise;\n    }\n\n    const loadPromise = this.loadSpriteWithRetry(asset, timeout, retryCount);\n    this.loadingPromises.set(`sprite:${asset.id}`, loadPromise);\n\n    try {\n      const loadedAsset = await loadPromise;\n      this.sprites.set(asset.id, loadedAsset);\n      return loadedAsset;\n    } finally {\n      this.loadingPromises.delete(`sprite:${asset.id}`);\n    }\n  }\n\n  /**\n   * Load a single font asset\n   */\n  async loadFontAsset(asset: FontAsset, timeout: number = 10000, retryCount: number = 2): Promise<LoadedFontAsset> {\n    // Check if already loaded\n    const existing = this.fonts.get(asset.id);\n    if (existing) {\n      return existing;\n    }\n\n    // Check if already loading\n    const existingPromise = this.loadingPromises.get(`font:${asset.id}`);\n    if (existingPromise) {\n      return existingPromise;\n    }\n\n    const loadPromise = this.loadFontWithRetry(asset, timeout, retryCount);\n    this.loadingPromises.set(`font:${asset.id}`, loadPromise);\n\n    try {\n      const loadedAsset = await loadPromise;\n      this.fonts.set(asset.id, loadedAsset);\n      return loadedAsset;\n    } finally {\n      this.loadingPromises.delete(`font:${asset.id}`);\n    }\n  }\n\n  /**\n   * Get a loaded sprite asset\n   */\n  getSprite(id: string): LoadedSpriteAsset | null {\n    return this.sprites.get(id) || null;\n  }\n\n  /**\n   * Get a loaded font asset\n   */\n  getFont(id: string): LoadedFontAsset | null {\n    return this.fonts.get(id) || null;\n  }\n\n  /**\n   * Get sprite with fallback to default\n   */\n  getSpriteWithFallback(id: string): HTMLImageElement {\n    const sprite = this.sprites.get(id);\n    if (sprite) {\n      return sprite.image;\n    }\n    \n    console.warn(`Sprite '${id}' not found, using fallback`);\n    return this.defaultSprite || this.createEmptyImage();\n  }\n\n  /**\n   * Get font family with fallback to default\n   */\n  getFontWithFallback(id: string): string {\n    const font = this.fonts.get(id);\n    if (font && font.loaded) {\n      return font.family;\n    }\n    \n    console.warn(`Font '${id}' not found or not loaded, using fallback`);\n    return this.defaultFont;\n  }\n\n  /**\n   * Clear all cached assets\n   */\n  clearCache(): void {\n    this.sprites.clear();\n    this.fonts.clear();\n    this.loadingPromises.clear();\n  }\n\n  /**\n   * Get memory usage statistics\n   */\n  getMemoryUsage(): { sprites: number; fonts: number; total: number } {\n    let spriteMemory = 0;\n    for (const sprite of this.sprites.values()) {\n      // Estimate memory usage: width * height * 4 bytes per pixel\n      spriteMemory += sprite.width * sprite.height * 4;\n    }\n\n    const fontMemory = this.fonts.size * 1024; // Rough estimate per font\n    \n    return {\n      sprites: spriteMemory,\n      fonts: fontMemory,\n      total: spriteMemory + fontMemory\n    };\n  }\n\n  /**\n   * Check if an asset is loaded\n   */\n  isAssetLoaded(id: string, type: 'sprite' | 'font'): boolean {\n    if (type === 'sprite') {\n      return this.sprites.has(id);\n    } else if (type === 'font') {\n      const font = this.fonts.get(id);\n      return font ? font.loaded : false;\n    }\n    return false;\n  }\n\n  private async loadSpriteWithRetry(asset: SpriteAsset, timeout: number, retryCount: number): Promise<LoadedSpriteAsset> {\n    let lastError: Error | null = null;\n    \n    for (let attempt = 0; attempt <= retryCount; attempt++) {\n      try {\n        return await this.loadSpriteImage(asset, timeout);\n      } catch (error) {\n        lastError = error as Error;\n        if (attempt < retryCount) {\n          // Wait before retry with exponential backoff\n          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n        }\n      }\n    }\n    \n    throw lastError;\n  }\n\n  private async loadFontWithRetry(asset: FontAsset, timeout: number, retryCount: number): Promise<LoadedFontAsset> {\n    let lastError: Error | null = null;\n    \n    for (let attempt = 0; attempt <= retryCount; attempt++) {\n      try {\n        return await this.loadFontFace(asset, timeout);\n      } catch (error) {\n        lastError = error as Error;\n        if (attempt < retryCount) {\n          // Wait before retry with exponential backoff\n          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n        }\n      }\n    }\n    \n    throw lastError;\n  }\n\n  private async loadSpriteImage(asset: SpriteAsset, timeout: number): Promise<LoadedSpriteAsset> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        img.onload = null;\n        img.onerror = null;\n      };\n\n      img.onload = () => {\n        cleanup();\n        resolve({\n          id: asset.id,\n          image: img,\n          width: asset.width,\n          height: asset.height,\n          frames: asset.frames || 1\n        });\n      };\n\n      img.onerror = () => {\n        cleanup();\n        reject(new Error(`Failed to load sprite: ${asset.url}`));\n      };\n\n      timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Sprite load timeout: ${asset.url}`));\n      }, timeout);\n\n      // Set crossOrigin to handle CORS if needed\n      img.crossOrigin = 'anonymous';\n      img.src = asset.url;\n    });\n  }\n\n  private async loadFontFace(asset: FontAsset, timeout: number): Promise<LoadedFontAsset> {\n    // Check if FontFace API is available\n    if (typeof FontFace === 'undefined') {\n      // Fallback for older browsers - just return the font family\n      return {\n        id: asset.id,\n        family: asset.family,\n        loaded: true\n      };\n    }\n\n    return new Promise((resolve, reject) => {\n      const fontFace = new FontFace(asset.family, `url(${asset.url})`);\n      let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      };\n\n      timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Font load timeout: ${asset.url}`));\n      }, timeout);\n\n      fontFace.load().then(() => {\n        cleanup();\n        // Add font to document\n        (document as any).fonts.add(fontFace);\n        \n        resolve({\n          id: asset.id,\n          family: asset.family,\n          loaded: true\n        });\n      }).catch((error) => {\n        cleanup();\n        reject(new Error(`Failed to load font: ${asset.url} - ${error.message}`));\n      });\n    });\n  }\n\n  private createDefaultAssets(): void {\n    // Create a simple 1x1 transparent pixel as default sprite\n    try {\n      const canvas = document.createElement('canvas');\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.fillStyle = 'rgba(255, 0, 255, 0.5)'; // Magenta to indicate missing asset\n        ctx.fillRect(0, 0, 1, 1);\n      }\n      \n      this.defaultSprite = new Image();\n      this.defaultSprite.src = canvas.toDataURL();\n    } catch (error) {\n      // Fallback for test environments without canvas support\n      this.defaultSprite = new Image();\n      this.defaultSprite.width = 1;\n      this.defaultSprite.height = 1;\n    }\n  }\n\n  private createEmptyImage(): HTMLImageElement {\n    const img = new Image();\n    img.width = 1;\n    img.height = 1;\n    return img;\n  }\n}","/**\n * Cartridge Loading System\n * Handles loading, parsing, and validation of LGF cartridges\n */\n\nimport { LGFCartridge } from '../types/core.js';\nimport { validateCartridge, ValidationResult } from './validator.js';\nimport { AssetManager, AssetLoadProgress, AssetLoadOptions } from './asset-manager.js';\nimport { AudioManager } from './audio-manager.js';\n\nexport interface CartridgeLoadProgress {\n  stage: 'parsing' | 'validating' | 'loading-assets';\n  progress: number; // 0-1\n  message: string;\n  assetProgress?: AssetLoadProgress;\n}\n\nexport interface CartridgeLoadOptions {\n  onProgress?: (progress: CartridgeLoadProgress) => void;\n  validateOnly?: boolean;\n  skipAssets?: boolean;\n  assetTimeout?: number;\n  assetRetryCount?: number;\n}\n\nexport interface LoadedCartridge {\n  cartridge: LGFCartridge;\n  validation: ValidationResult;\n  assetManager: AssetManager;\n  audioManager: AudioManager;\n}\n\nexport class CartridgeLoader {\n  private assetManager: AssetManager;\n  private audioManager: AudioManager;\n\n  constructor(assetManager?: AssetManager, audioManager?: AudioManager) {\n    this.assetManager = assetManager || new AssetManager();\n    this.audioManager = audioManager || new AudioManager();\n  }\n\n  /**\n   * Load a cartridge from JSON string\n   */\n  async loadFromJSON(jsonString: string, options: CartridgeLoadOptions = {}): Promise<LoadedCartridge> {\n    const { onProgress, validateOnly = false, skipAssets = false } = options;\n\n    // Stage 1: Parse JSON\n    if (onProgress) {\n      onProgress({\n        stage: 'parsing',\n        progress: 0,\n        message: 'Parsing cartridge JSON...'\n      });\n    }\n\n    let cartridge: any;\n    try {\n      cartridge = JSON.parse(jsonString);\n    } catch (error) {\n      throw new Error(`Invalid JSON: ${error instanceof Error ? error.message : 'Unknown parsing error'}`);\n    }\n\n    if (onProgress) {\n      onProgress({\n        stage: 'parsing',\n        progress: 1,\n        message: 'JSON parsed successfully'\n      });\n    }\n\n    // Stage 2: Validate cartridge\n    if (onProgress) {\n      onProgress({\n        stage: 'validating',\n        progress: 0,\n        message: 'Validating cartridge format...'\n      });\n    }\n\n    const validation = validateCartridge(cartridge);\n    \n    if (onProgress) {\n      onProgress({\n        stage: 'validating',\n        progress: 1,\n        message: validation.valid ? 'Validation successful' : `Validation failed with ${validation.errors.length} errors`\n      });\n    }\n\n    if (!validation.valid) {\n      throw new Error(`Cartridge validation failed:\\n${validation.errors.map(e => `- ${e.path}: ${e.message}`).join('\\n')}`);\n    }\n\n    if (validateOnly) {\n      return {\n        cartridge: cartridge as LGFCartridge,\n        validation,\n        assetManager: this.assetManager,\n        audioManager: this.audioManager\n      };\n    }\n\n    // Stage 3: Load assets\n    if (!skipAssets && cartridge.assets) {\n      if (onProgress) {\n        onProgress({\n          stage: 'loading-assets',\n          progress: 0,\n          message: 'Loading assets...'\n        });\n      }\n\n      await this.loadCartridgeAssets(cartridge as LGFCartridge, {\n        onProgress: (assetProgress) => {\n          if (onProgress) {\n            onProgress({\n              stage: 'loading-assets',\n              progress: assetProgress.progress,\n              message: `Loading assets... (${assetProgress.loaded}/${assetProgress.total})`,\n              assetProgress\n            });\n          }\n        },\n        timeout: options.assetTimeout,\n        retryCount: options.assetRetryCount\n      });\n    }\n\n    return {\n      cartridge: cartridge as LGFCartridge,\n      validation,\n      assetManager: this.assetManager,\n      audioManager: this.audioManager\n    };\n  }\n\n  /**\n   * Load a cartridge from a URL\n   */\n  async loadFromURL(url: string, options: CartridgeLoadOptions = {}): Promise<LoadedCartridge> {\n    const { onProgress } = options;\n\n    if (onProgress) {\n      onProgress({\n        stage: 'parsing',\n        progress: 0,\n        message: `Fetching cartridge from ${url}...`\n      });\n    }\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const jsonString = await response.text();\n      \n      if (onProgress) {\n        onProgress({\n          stage: 'parsing',\n          progress: 0.5,\n          message: 'Cartridge downloaded, parsing...'\n        });\n      }\n\n      return await this.loadFromJSON(jsonString, options);\n    } catch (error) {\n      throw new Error(`Failed to load cartridge from URL: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Load a cartridge from a File object (for file uploads)\n   */\n  async loadFromFile(file: File, options: CartridgeLoadOptions = {}): Promise<LoadedCartridge> {\n    const { onProgress } = options;\n\n    if (onProgress) {\n      onProgress({\n        stage: 'parsing',\n        progress: 0,\n        message: `Reading file ${file.name}...`\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = async (event) => {\n        try {\n          const jsonString = event.target?.result as string;\n          \n          if (onProgress) {\n            onProgress({\n              stage: 'parsing',\n              progress: 0.5,\n              message: 'File read, parsing...'\n            });\n          }\n\n          const result = await this.loadFromJSON(jsonString, options);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      reader.onerror = () => {\n        reject(new Error(`Failed to read file: ${reader.error?.message || 'Unknown error'}`));\n      };\n\n      reader.readAsText(file);\n    });\n  }\n\n  /**\n   * Validate a cartridge without loading assets\n   */\n  async validateCartridge(cartridge: string | object): Promise<ValidationResult> {\n    let parsedCartridge: any;\n\n    if (typeof cartridge === 'string') {\n      try {\n        parsedCartridge = JSON.parse(cartridge);\n      } catch (error) {\n        return {\n          valid: false,\n          errors: [{\n            path: '',\n            message: `Invalid JSON: ${error instanceof Error ? error.message : 'Unknown parsing error'}`,\n            code: 'JSON_PARSE_ERROR'\n          }],\n          warnings: []\n        };\n      }\n    } else {\n      parsedCartridge = cartridge;\n    }\n\n    return validateCartridge(parsedCartridge);\n  }\n\n  /**\n   * Get asset manager instance\n   */\n  getAssetManager(): AssetManager {\n    return this.assetManager;\n  }\n\n  /**\n   * Get audio manager instance\n   */\n  getAudioManager(): AudioManager {\n    return this.audioManager;\n  }\n\n  /**\n   * Clear all cached assets\n   */\n  clearCache(): void {\n    this.assetManager.clearCache();\n    this.audioManager.cleanup();\n  }\n\n  /**\n   * Get memory usage statistics\n   */\n  getMemoryUsage(): { assets: any; audio: number; total: number } {\n    const assetMemory = this.assetManager.getMemoryUsage();\n    const audioMemory = 0; // AudioManager doesn't expose memory usage yet\n    \n    return {\n      assets: assetMemory,\n      audio: audioMemory,\n      total: assetMemory.total + audioMemory\n    };\n  }\n\n  private async loadCartridgeAssets(cartridge: LGFCartridge, options: AssetLoadOptions): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    // Load sprite and font assets through AssetManager\n    if (cartridge.assets.sprites.length > 0 || cartridge.assets.fonts.length > 0) {\n      promises.push(\n        this.assetManager.loadAssets({\n          sprites: cartridge.assets.sprites,\n          audio: [], // Audio handled separately\n          fonts: cartridge.assets.fonts\n        }, options).catch(error => {\n          console.warn('Asset loading failed:', error);\n          // Don't throw - allow cartridge to load with missing assets\n        })\n      );\n    }\n\n    // Load audio assets through AudioManager\n    if (cartridge.assets.audio.length > 0) {\n      promises.push(\n        this.audioManager.loadAssets(cartridge.assets.audio).catch(error => {\n          console.warn('Audio asset loading failed:', error);\n          // Don't throw - allow cartridge to load with missing audio\n        })\n      );\n    }\n\n    await Promise.allSettled(promises);\n  }\n}\n\n/**\n * Convenience function to create a cartridge loader\n */\nexport function createCartridgeLoader(assetManager?: AssetManager, audioManager?: AudioManager): CartridgeLoader {\n  return new CartridgeLoader(assetManager, audioManager);\n}\n\n/**\n * Convenience function to load a cartridge from JSON\n */\nexport async function loadCartridge(jsonString: string, options?: CartridgeLoadOptions): Promise<LoadedCartridge> {\n  const loader = new CartridgeLoader();\n  return loader.loadFromJSON(jsonString, options);\n}","/**\n * Accessibility Manager for the LLM Canvas Engine\n * Handles keyboard navigation, screen reader support, and accessibility features\n */\n\nimport { Node, ThemeTokens } from '../types/core.js';\nimport { InputManager } from './input-manager.js';\n\nexport interface AccessibilityOptions {\n  enableKeyboardNavigation: boolean;\n  enableScreenReader: boolean;\n  enableHighContrast: boolean;\n  textScaling: number;\n  enableFocusIndicators: boolean;\n  announceStateChanges: boolean;\n}\n\nexport interface FocusableElement {\n  node: Node;\n  element: HTMLElement;\n  tabIndex: number;\n  ariaLabel: string;\n  ariaRole: string;\n}\n\nexport interface AccessibilityState {\n  currentFocus: FocusableElement | null;\n  focusableElements: FocusableElement[];\n  isHighContrast: boolean;\n  textScaling: number;\n  screenReaderEnabled: boolean;\n}\n\n/**\n * Manages accessibility features including keyboard navigation,\n * screen reader support, and visual accessibility enhancements\n */\nexport class AccessibilityManager {\n  private options: AccessibilityOptions;\n  private state: AccessibilityState;\n  private canvas: HTMLCanvasElement | null = null;\n  private inputManager: InputManager | null = null;\n  private ariaLiveRegion: HTMLElement | null = null;\n  private focusIndicator: HTMLElement | null = null;\n  private originalTheme: ThemeTokens | null = null;\n  private highContrastTheme: ThemeTokens | null = null;\n\n  constructor(options: Partial<AccessibilityOptions> = {}) {\n    this.options = {\n      enableKeyboardNavigation: true,\n      enableScreenReader: true,\n      enableHighContrast: false,\n      textScaling: 1.0,\n      enableFocusIndicators: true,\n      announceStateChanges: true,\n      ...options\n    };\n\n    this.state = {\n      currentFocus: null,\n      focusableElements: [],\n      isHighContrast: this.options.enableHighContrast,\n      textScaling: this.options.textScaling,\n      screenReaderEnabled: this.options.enableScreenReader\n    };\n\n    this.setupAccessibilityFeatures();\n  }\n\n  /**\n   * Initialize accessibility manager with canvas and input manager\n   */\n  initialize(canvas: HTMLCanvasElement, inputManager: InputManager): void {\n    this.canvas = canvas;\n    this.inputManager = inputManager;\n\n    this.setupCanvasAccessibility();\n    this.setupKeyboardNavigation();\n    this.setupScreenReaderSupport();\n    this.setupFocusManagement();\n  }\n\n  /**\n   * Update accessibility state and handle focus management\n   */\n  update(sceneNodes: Node[]): void {\n    if (!this.options.enableKeyboardNavigation) return;\n\n    // Update focusable elements from scene\n    this.updateFocusableElements(sceneNodes);\n\n    // Handle keyboard navigation\n    this.handleKeyboardNavigation();\n\n    // Update focus indicators\n    this.updateFocusIndicators();\n  }\n\n  /**\n   * Set theme and create high contrast variant\n   */\n  setTheme(theme: ThemeTokens): void {\n    this.originalTheme = theme;\n    this.highContrastTheme = this.createHighContrastTheme(theme);\n\n    if (this.state.isHighContrast) {\n      this.applyHighContrastTheme();\n    }\n  }\n\n  /**\n   * Toggle high contrast mode\n   */\n  toggleHighContrast(): ThemeTokens {\n    this.state.isHighContrast = !this.state.isHighContrast;\n    \n    if (this.state.isHighContrast) {\n      this.announceToScreenReader('High contrast mode enabled');\n      return this.applyHighContrastTheme();\n    } else {\n      this.announceToScreenReader('High contrast mode disabled');\n      return this.originalTheme || this.createDefaultTheme();\n    }\n  }\n\n  /**\n   * Set text scaling factor\n   */\n  setTextScaling(scale: number): void {\n    this.state.textScaling = Math.max(0.5, Math.min(3.0, scale));\n    this.announceToScreenReader(`Text scaling set to ${Math.round(this.state.textScaling * 100)}%`);\n  }\n\n  /**\n   * Get current text scaling factor\n   */\n  getTextScaling(): number {\n    return this.state.textScaling;\n  }\n\n  /**\n   * Focus on a specific node\n   */\n  focusNode(nodeId: string): boolean {\n    const focusable = this.state.focusableElements.find(el => el.node.id === nodeId);\n    if (focusable) {\n      this.setFocus(focusable);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get currently focused node\n   */\n  getCurrentFocus(): Node | null {\n    return this.state.currentFocus?.node || null;\n  }\n\n  /**\n   * Announce message to screen reader\n   */\n  announceToScreenReader(message: string, priority: 'polite' | 'assertive' = 'polite'): void {\n    if (!this.state.screenReaderEnabled || !this.ariaLiveRegion) return;\n\n    this.ariaLiveRegion.setAttribute('aria-live', priority);\n    this.ariaLiveRegion.textContent = message;\n\n    // Clear after announcement\n    setTimeout(() => {\n      if (this.ariaLiveRegion) {\n        this.ariaLiveRegion.textContent = '';\n      }\n    }, 1000);\n  }\n\n  /**\n   * Get accessibility state for debugging\n   */\n  getAccessibilityState(): AccessibilityState {\n    return { ...this.state };\n  }\n\n  /**\n   * Cleanup accessibility features\n   */\n  cleanup(): void {\n    if (this.ariaLiveRegion) {\n      this.ariaLiveRegion.remove();\n      this.ariaLiveRegion = null;\n    }\n\n    if (this.focusIndicator) {\n      this.focusIndicator.remove();\n      this.focusIndicator = null;\n    }\n\n    this.state.focusableElements = [];\n    this.state.currentFocus = null;\n  }\n\n  private setupAccessibilityFeatures(): void {\n    // Detect if user prefers reduced motion\n    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n    if (prefersReducedMotion) {\n      // TODO: Implement reduced motion features\n    }\n    \n    // Detect if user prefers high contrast\n    const prefersHighContrast = window.matchMedia('(prefers-contrast: high)').matches;\n    if (prefersHighContrast) {\n      this.options.enableHighContrast = true;\n      this.state.isHighContrast = true;\n    }\n\n    // Listen for system accessibility changes\n    window.matchMedia('(prefers-contrast: high)').addEventListener('change', (e) => {\n      if (e.matches && !this.state.isHighContrast) {\n        this.state.isHighContrast = true;\n        this.applyHighContrastTheme();\n      }\n    });\n  }\n\n  private setupCanvasAccessibility(): void {\n    if (!this.canvas) return;\n\n    // Make canvas accessible\n    this.canvas.setAttribute('role', 'application');\n    this.canvas.setAttribute('aria-label', 'Game Canvas');\n    this.canvas.setAttribute('tabindex', '0');\n\n    // Add canvas description\n    const canvasDescription = document.createElement('div');\n    canvasDescription.id = 'canvas-description';\n    canvasDescription.style.position = 'absolute';\n    canvasDescription.style.left = '-10000px';\n    canvasDescription.textContent = 'Interactive game canvas. Use arrow keys to navigate, Enter to interact, and Tab to cycle through interactive elements.';\n    document.body.appendChild(canvasDescription);\n    \n    this.canvas.setAttribute('aria-describedby', 'canvas-description');\n  }\n\n  private setupKeyboardNavigation(): void {\n    if (!this.inputManager || !this.options.enableKeyboardNavigation) return;\n\n    // Map accessibility keys\n    this.inputManager.mapKey('tab', 'focus_next');\n    this.inputManager.mapKey('shift+tab', 'focus_previous');\n    this.inputManager.mapKey('enter', 'activate');\n    this.inputManager.mapKey('space', 'activate');\n    this.inputManager.mapKey('escape', 'cancel');\n    this.inputManager.mapKey('home', 'focus_first');\n    this.inputManager.mapKey('end', 'focus_last');\n    this.inputManager.mapKey('up', 'navigate_up');\n    this.inputManager.mapKey('down', 'navigate_down');\n    this.inputManager.mapKey('left', 'navigate_left');\n    this.inputManager.mapKey('right', 'navigate_right');\n  }\n\n  private setupScreenReaderSupport(): void {\n    if (!this.options.enableScreenReader) return;\n\n    // Create ARIA live region for announcements\n    this.ariaLiveRegion = document.createElement('div');\n    this.ariaLiveRegion.setAttribute('aria-live', 'polite');\n    this.ariaLiveRegion.setAttribute('aria-atomic', 'true');\n    this.ariaLiveRegion.style.position = 'absolute';\n    this.ariaLiveRegion.style.left = '-10000px';\n    this.ariaLiveRegion.style.width = '1px';\n    this.ariaLiveRegion.style.height = '1px';\n    this.ariaLiveRegion.style.overflow = 'hidden';\n    document.body.appendChild(this.ariaLiveRegion);\n  }\n\n  private setupFocusManagement(): void {\n    if (!this.options.enableFocusIndicators) return;\n\n    // Create focus indicator element\n    this.focusIndicator = document.createElement('div');\n    this.focusIndicator.style.position = 'absolute';\n    this.focusIndicator.style.border = '2px solid #007acc';\n    this.focusIndicator.style.borderRadius = '4px';\n    this.focusIndicator.style.pointerEvents = 'none';\n    this.focusIndicator.style.zIndex = '1000';\n    this.focusIndicator.style.display = 'none';\n    this.focusIndicator.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(this.focusIndicator);\n  }\n\n  private updateFocusableElements(nodes: Node[]): void {\n    this.state.focusableElements = [];\n    this.collectFocusableElements(nodes, 0);\n    \n    // Sort by tab index and position\n    this.state.focusableElements.sort((a, b) => {\n      if (a.tabIndex !== b.tabIndex) {\n        return a.tabIndex - b.tabIndex;\n      }\n      // Sort by position for spatial navigation\n      const aPos = a.node.getWorldTransform().position;\n      const bPos = b.node.getWorldTransform().position;\n      return aPos.y - bPos.y || aPos.x - bPos.x;\n    });\n  }\n\n  private collectFocusableElements(nodes: Node[], tabIndex: number): void {\n    for (const node of nodes) {\n      if (this.isFocusable(node)) {\n        const element = this.createVirtualElement(node);\n        this.state.focusableElements.push({\n          node,\n          element,\n          tabIndex,\n          ariaLabel: this.getAriaLabel(node),\n          ariaRole: this.getAriaRole(node)\n        });\n        tabIndex++;\n      }\n\n      if (node.children) {\n        this.collectFocusableElements(node.children, tabIndex);\n      }\n    }\n  }\n\n  private isFocusable(node: Node): boolean {\n    const isWorldVisible = typeof (node as any).isWorldVisible === 'function' \n      ? (node as any).isWorldVisible() \n      : node.visible; // Fallback for plain objects\n    \n    return node.visible && \n           isWorldVisible && \n           (node.type === 'Button' || \n            node.type === 'Text' && (node as any).interactive ||\n            (node as any).focusable === true);\n  }\n\n  private createVirtualElement(node: Node): HTMLElement {\n    const element = document.createElement('div');\n    element.setAttribute('role', this.getAriaRole(node));\n    element.setAttribute('aria-label', this.getAriaLabel(node));\n    element.style.position = 'absolute';\n    element.style.left = '-10000px';\n    return element;\n  }\n\n  private getAriaLabel(node: Node): string {\n    const nodeData = node as any;\n    return nodeData.ariaLabel || \n           nodeData.text || \n           nodeData.label || \n           `${node.type} ${node.id}`;\n  }\n\n  private getAriaRole(node: Node): string {\n    switch (node.type) {\n      case 'Button': return 'button';\n      case 'Text': return 'text';\n      default: return 'generic';\n    }\n  }\n\n  private handleKeyboardNavigation(): void {\n    if (!this.inputManager) return;\n\n    if (this.inputManager.isActionJustPressed('focus_next')) {\n      this.focusNext();\n    } else if (this.inputManager.isActionJustPressed('focus_previous')) {\n      this.focusPrevious();\n    } else if (this.inputManager.isActionJustPressed('focus_first')) {\n      this.focusFirst();\n    } else if (this.inputManager.isActionJustPressed('focus_last')) {\n      this.focusLast();\n    } else if (this.inputManager.isActionJustPressed('activate')) {\n      this.activateCurrentFocus();\n    } else if (this.inputManager.isActionJustPressed('cancel')) {\n      this.clearFocus();\n    }\n\n    // Spatial navigation\n    if (this.inputManager.isActionJustPressed('navigate_up')) {\n      this.navigateDirection('up');\n    } else if (this.inputManager.isActionJustPressed('navigate_down')) {\n      this.navigateDirection('down');\n    } else if (this.inputManager.isActionJustPressed('navigate_left')) {\n      this.navigateDirection('left');\n    } else if (this.inputManager.isActionJustPressed('navigate_right')) {\n      this.navigateDirection('right');\n    }\n  }\n\n  private focusNext(): void {\n    if (this.state.focusableElements.length === 0) return;\n\n    const currentIndex = this.getCurrentFocusIndex();\n    const nextIndex = (currentIndex + 1) % this.state.focusableElements.length;\n    this.setFocus(this.state.focusableElements[nextIndex]);\n  }\n\n  private focusPrevious(): void {\n    if (this.state.focusableElements.length === 0) return;\n\n    const currentIndex = this.getCurrentFocusIndex();\n    const prevIndex = currentIndex === 0 ? \n      this.state.focusableElements.length - 1 : \n      currentIndex - 1;\n    this.setFocus(this.state.focusableElements[prevIndex]);\n  }\n\n  private focusFirst(): void {\n    if (this.state.focusableElements.length > 0) {\n      this.setFocus(this.state.focusableElements[0]);\n    }\n  }\n\n  private focusLast(): void {\n    if (this.state.focusableElements.length > 0) {\n      this.setFocus(this.state.focusableElements[this.state.focusableElements.length - 1]);\n    }\n  }\n\n  private navigateDirection(direction: 'up' | 'down' | 'left' | 'right'): void {\n    if (!this.state.currentFocus) {\n      this.focusFirst();\n      return;\n    }\n\n    const currentPos = this.state.currentFocus.node.getWorldTransform().position;\n    let bestCandidate: FocusableElement | null = null;\n    let bestDistance = Infinity;\n\n    for (const element of this.state.focusableElements) {\n      if (element === this.state.currentFocus) continue;\n\n      const pos = element.node.getWorldTransform().position;\n      const dx = pos.x - currentPos.x;\n      const dy = pos.y - currentPos.y;\n\n      // Check if element is in the correct direction\n      let isInDirection = false;\n      switch (direction) {\n        case 'up': isInDirection = dy < -10; break;\n        case 'down': isInDirection = dy > 10; break;\n        case 'left': isInDirection = dx < -10; break;\n        case 'right': isInDirection = dx > 10; break;\n      }\n\n      if (isInDirection) {\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestCandidate = element;\n        }\n      }\n    }\n\n    if (bestCandidate) {\n      this.setFocus(bestCandidate);\n    }\n  }\n\n  private getCurrentFocusIndex(): number {\n    if (!this.state.currentFocus) return -1;\n    return this.state.focusableElements.indexOf(this.state.currentFocus);\n  }\n\n  private setFocus(element: FocusableElement): void {\n    this.state.currentFocus = element;\n    \n    // Announce focus change to screen reader\n    if (this.options.announceStateChanges && element) {\n      this.announceToScreenReader(`Focused on ${element.ariaLabel}`);\n    }\n\n    // Update visual focus indicator\n    this.updateFocusIndicators();\n  }\n\n  private clearFocus(): void {\n    this.state.currentFocus = null;\n    this.updateFocusIndicators();\n  }\n\n  private activateCurrentFocus(): void {\n    if (!this.state.currentFocus) return;\n\n    const node = this.state.currentFocus.node;\n    \n    // Trigger node activation (simulate click/tap)\n    if (node.type === 'Button') {\n      this.announceToScreenReader(`Activated ${this.state.currentFocus.ariaLabel}`);\n      // TODO: Trigger button action\n    }\n  }\n\n  private updateFocusIndicators(): void {\n    if (!this.focusIndicator || !this.canvas) return;\n\n    if (!this.state.currentFocus) {\n      this.focusIndicator.style.display = 'none';\n      return;\n    }\n\n    // Calculate focus indicator position\n    const node = this.state.currentFocus.node;\n    const transform = typeof (node as any).getWorldTransform === 'function' \n      ? (node as any).getWorldTransform() \n      : node.transform; // Fallback to local transform for plain objects\n    const canvasRect = this.canvas.getBoundingClientRect();\n    \n    // Convert world position to screen position\n    // This is simplified - in a full implementation, this would use the renderer's coordinate conversion\n    const screenX = canvasRect.left + transform.position.x;\n    const screenY = canvasRect.top + transform.position.y;\n    \n    // Position and show focus indicator\n    this.focusIndicator.style.left = `${screenX - 25}px`;\n    this.focusIndicator.style.top = `${screenY - 25}px`;\n    this.focusIndicator.style.width = '50px';\n    this.focusIndicator.style.height = '50px';\n    this.focusIndicator.style.display = 'block';\n  }\n\n  private createHighContrastTheme(originalTheme: ThemeTokens): ThemeTokens {\n    return {\n      colors: {\n        primary: '#ffffff',\n        secondary: '#000000',\n        background: '#000000',\n        text: '#ffffff',\n        accent: '#ffff00'\n      },\n      font: {\n        ...originalTheme.font,\n        sizes: Object.fromEntries(\n          Object.entries(originalTheme.font.sizes).map(([key, size]) => [\n            key, \n            Math.round(size * this.state.textScaling)\n          ])\n        )\n      },\n      spacing: originalTheme.spacing,\n      radii: originalTheme.radii\n    };\n  }\n\n  private applyHighContrastTheme(): ThemeTokens {\n    // Always recreate to apply current text scaling\n    this.highContrastTheme = this.createHighContrastTheme(\n      this.originalTheme || this.createDefaultTheme()\n    );\n    return this.highContrastTheme;\n  }\n\n  private createDefaultTheme(): ThemeTokens {\n    return {\n      colors: {\n        primary: '#007acc',\n        secondary: '#666666',\n        background: '#ffffff',\n        text: '#000000',\n        accent: '#ff6600'\n      },\n      font: {\n        family: 'Arial, sans-serif',\n        sizes: {\n          small: 12,\n          medium: 16,\n          large: 24\n        }\n      },\n      spacing: {\n        small: 4,\n        medium: 8,\n        large: 16\n      },\n      radii: {\n        small: 2,\n        medium: 4,\n        large: 8\n      }\n    };\n  }\n}","/**\n * Core LLMRTEngine implementation\n */\n\nimport { LLMRTEngine, EngineState, LGFCartridge, InputManager, AudioManager } from '../types/core.js';\nimport { ModuleRegistry } from './module-registry.js';\nimport { InputManagerImpl } from './input-manager.js';\nimport { AudioManager as AudioManagerImpl } from './audio-manager.js';\nimport { CartridgeLoader, CartridgeLoadOptions } from './cartridge-loader.js';\nimport { AssetManager } from './asset-manager.js';\nimport { AccessibilityManager, AccessibilityOptions } from './accessibility-manager.js';\n\nexport class LLMRTEngineImpl implements LLMRTEngine {\n  private state: EngineState = {\n    running: false,\n    paused: false,\n    currentScene: null,\n    tickCount: 0,\n    frameRate: 0\n  };\n\n  private cartridge: LGFCartridge | null = null;\n  private moduleRegistry: ModuleRegistry;\n  private inputManager: InputManager;\n  private audioManager: AudioManager;\n  private assetManager: AssetManager;\n  private cartridgeLoader: CartridgeLoader;\n  private accessibilityManager: AccessibilityManager;\n\n  constructor(accessibilityOptions?: Partial<AccessibilityOptions>) {\n    this.moduleRegistry = ModuleRegistry.getInstance();\n    this.inputManager = new InputManagerImpl();\n    this.audioManager = new AudioManagerImpl();\n    this.assetManager = new AssetManager();\n    this.cartridgeLoader = new CartridgeLoader(this.assetManager, this.audioManager);\n    this.accessibilityManager = new AccessibilityManager(accessibilityOptions);\n  }\n\n  async loadCartridge(cartridge: LGFCartridge, options?: CartridgeLoadOptions): Promise<void> {\n    // Use the cartridge loader for comprehensive loading\n    const result = await this.cartridgeLoader.loadFromJSON(JSON.stringify(cartridge), options);\n    \n    // Validate that all node types are supported\n    for (const scene of result.cartridge.scenes) {\n      this.validateNodeTree(scene.root);\n    }\n\n    this.cartridge = result.cartridge;\n    \n    // Set initial scene if available\n    if (result.cartridge.scenes.length > 0) {\n      this.state.currentScene = result.cartridge.scenes[0].id;\n    }\n  }\n\n  /**\n   * Load cartridge from JSON string\n   */\n  async loadCartridgeFromJSON(jsonString: string, options?: CartridgeLoadOptions): Promise<void> {\n    const result = await this.cartridgeLoader.loadFromJSON(jsonString, options);\n    \n    // Validate that all node types are supported\n    for (const scene of result.cartridge.scenes) {\n      this.validateNodeTree(scene.root);\n    }\n\n    this.cartridge = result.cartridge;\n    \n    // Set initial scene if available\n    if (result.cartridge.scenes.length > 0) {\n      this.state.currentScene = result.cartridge.scenes[0].id;\n    }\n  }\n\n  /**\n   * Load cartridge from URL\n   */\n  async loadCartridgeFromURL(url: string, options?: CartridgeLoadOptions): Promise<void> {\n    const result = await this.cartridgeLoader.loadFromURL(url, options);\n    \n    // Validate that all node types are supported\n    for (const scene of result.cartridge.scenes) {\n      this.validateNodeTree(scene.root);\n    }\n\n    this.cartridge = result.cartridge;\n    \n    // Set initial scene if available\n    if (result.cartridge.scenes.length > 0) {\n      this.state.currentScene = result.cartridge.scenes[0].id;\n    }\n  }\n\n  /**\n   * Load cartridge from File object\n   */\n  async loadCartridgeFromFile(file: File, options?: CartridgeLoadOptions): Promise<void> {\n    const result = await this.cartridgeLoader.loadFromFile(file, options);\n    \n    // Validate that all node types are supported\n    for (const scene of result.cartridge.scenes) {\n      this.validateNodeTree(scene.root);\n    }\n\n    this.cartridge = result.cartridge;\n    \n    // Set initial scene if available\n    if (result.cartridge.scenes.length > 0) {\n      this.state.currentScene = result.cartridge.scenes[0].id;\n    }\n  }\n\n  start(): void {\n    if (!this.cartridge) {\n      throw new Error('No cartridge loaded');\n    }\n\n    this.state.running = true;\n    this.state.paused = false;\n    this.state.tickCount = 0;\n  }\n\n  stop(): void {\n    this.state.running = false;\n    this.state.paused = false;\n    this.state.tickCount = 0;\n    this.audioManager.stopMusic();\n  }\n\n  pause(): void {\n    if (this.state.running) {\n      this.state.paused = true;\n    }\n  }\n\n  resume(): void {\n    if (this.state.running) {\n      this.state.paused = false;\n    }\n  }\n\n  getState(): EngineState {\n    return { ...this.state };\n  }\n\n  getInputManager(): InputManager {\n    return this.inputManager;\n  }\n\n  getAudioManager(): AudioManager {\n    return this.audioManager;\n  }\n\n  /**\n   * Get asset manager instance\n   */\n  getAssetManager(): AssetManager {\n    return this.assetManager;\n  }\n\n  /**\n   * Get cartridge loader instance\n   */\n  getCartridgeLoader(): CartridgeLoader {\n    return this.cartridgeLoader;\n  }\n\n  /**\n   * Get accessibility manager instance\n   */\n  getAccessibilityManager(): AccessibilityManager {\n    return this.accessibilityManager;\n  }\n\n  private validateNodeTree(node: any): void {\n    if (!node.type || !this.moduleRegistry.supportsNodeType(node.type)) {\n      throw new Error(`Unsupported node type: ${node.type}`);\n    }\n\n    // Validate triggers\n    if (node.triggers && Array.isArray(node.triggers)) {\n      for (const trigger of node.triggers) {\n        if (!this.moduleRegistry.supportsTriggerEvent(trigger.event)) {\n          throw new Error(`Unsupported trigger event: ${trigger.event}`);\n        }\n      }\n    }\n\n    // Recursively validate children\n    if (node.children && Array.isArray(node.children)) {\n      for (const child of node.children) {\n        this.validateNodeTree(child);\n      }\n    }\n  }\n}","/**\n * Scene tree system for hierarchical node management\n */\n\nimport { Node, NodeType, Transform2D } from '../types/core.js';\nimport { Action, Trigger } from '../types/actions.js';\n\n/**\n * Base Node implementation with transform, visibility, and hierarchy support\n */\nexport class NodeImpl implements Node {\n  public id: string;\n  public type: NodeType;\n  public transform: Transform2D;\n  public visible: boolean;\n  public children: Node[];\n  public actions: Action[];\n  public triggers: Trigger[];\n  public parent: Node | null = null;\n\n  constructor(id: string, type: NodeType) {\n    this.id = id;\n    this.type = type;\n    this.transform = {\n      position: { x: 0, y: 0 },\n      scale: { x: 1, y: 1 },\n      rotation: 0,\n      skew: { x: 0, y: 0 },\n      alpha: 1\n    };\n    this.visible = true;\n    this.children = [];\n    this.actions = [];\n    this.triggers = [];\n  }\n\n  /**\n   * Add a child node to this node\n   */\n  addChild(child: Node): void {\n    if (child === this) {\n      throw new Error('Cannot add node as child of itself');\n    }\n\n    // Check for circular reference\n    if (this.isDescendantOf(child)) {\n      throw new Error('Cannot add ancestor as child (circular reference)');\n    }\n\n    // Remove from previous parent if any\n    if ((child as NodeImpl).parent) {\n      (child as NodeImpl).parent!.removeChild(child);\n    }\n\n    this.children.push(child);\n    (child as NodeImpl).parent = this;\n  }\n\n  /**\n   * Remove a child node from this node\n   */\n  removeChild(child: Node): boolean {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      return false;\n    }\n\n    this.children.splice(index, 1);\n    (child as NodeImpl).parent = null;\n    return true;\n  }\n\n  /**\n   * Remove this node from its parent\n   */\n  removeFromParent(): boolean {\n    if (!this.parent) {\n      return false;\n    }\n\n    return this.parent.removeChild(this);\n  }\n\n  /**\n   * Check if this node is a descendant of the given node\n   */\n  private isDescendantOf(node: Node): boolean {\n    let current = this.parent;\n    while (current) {\n      if (current === node) {\n        return true;\n      }\n      current = (current as NodeImpl).parent;\n    }\n    return false;\n  }\n\n  /**\n   * Get the root node of the tree\n   */\n  getRoot(): Node {\n    let current: Node = this;\n    while ((current as NodeImpl).parent) {\n      current = (current as NodeImpl).parent!;\n    }\n    return current;\n  }\n\n  /**\n   * Get the depth of this node in the tree (root = 0)\n   */\n  getDepth(): number {\n    let depth = 0;\n    let current = this.parent;\n    while (current) {\n      depth++;\n      current = (current as NodeImpl).parent;\n    }\n    return depth;\n  }\n\n  /**\n   * Get world transform by combining with parent transforms\n   */\n  getWorldTransform(): Transform2D {\n    if (!this.parent) {\n      return { ...this.transform };\n    }\n\n    const parentWorld = (this.parent as NodeImpl).getWorldTransform();\n    \n    // Combine transforms (simplified - in a real engine this would use matrices)\n    return {\n      position: {\n        x: parentWorld.position.x + this.transform.position.x * parentWorld.scale.x,\n        y: parentWorld.position.y + this.transform.position.y * parentWorld.scale.y\n      },\n      scale: {\n        x: parentWorld.scale.x * this.transform.scale.x,\n        y: parentWorld.scale.y * this.transform.scale.y\n      },\n      rotation: parentWorld.rotation + this.transform.rotation,\n      skew: {\n        x: parentWorld.skew.x + this.transform.skew.x,\n        y: parentWorld.skew.y + this.transform.skew.y\n      },\n      alpha: parentWorld.alpha * this.transform.alpha\n    };\n  }\n\n  /**\n   * Check if this node is visible in the world (considering parent visibility)\n   */\n  isWorldVisible(): boolean {\n    if (!this.visible) {\n      return false;\n    }\n\n    let current = this.parent;\n    while (current) {\n      if (!current.visible) {\n        return false;\n      }\n      current = (current as NodeImpl).parent;\n    }\n    return true;\n  }\n}\n\n/**\n * Scene tree manager for node operations\n */\nexport class SceneTree {\n  private root: Node;\n  private nodeMap = new Map<string, Node>();\n\n  constructor(root: Node) {\n    this.root = root;\n    this.buildNodeMap(root);\n  }\n\n  /**\n   * Get the root node of the scene\n   */\n  getRoot(): Node {\n    return this.root;\n  }\n\n  /**\n   * Add a node to the scene tree under the specified parent\n   */\n  addNode(node: Node, parentId?: string): void {\n    const parent = parentId ? this.findNode(parentId) : this.root;\n    if (!parent) {\n      throw new Error(`Parent node with id '${parentId}' not found`);\n    }\n\n    // Check for duplicate IDs\n    if (this.nodeMap.has(node.id)) {\n      throw new Error(`Node with id '${node.id}' already exists in scene`);\n    }\n\n    parent.addChild(node);\n    this.addToNodeMap(node);\n  }\n\n  /**\n   * Remove a node from the scene tree\n   */\n  removeNode(nodeId: string): boolean {\n    const node = this.findNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    // Remove from parent\n    const removed = (node as NodeImpl).removeFromParent();\n    if (removed) {\n      this.removeFromNodeMap(node);\n    }\n\n    return removed;\n  }\n\n  /**\n   * Find a node by its ID\n   */\n  findNode(nodeId: string): Node | null {\n    return this.nodeMap.get(nodeId) || null;\n  }\n\n  /**\n   * Find nodes by type\n   */\n  findNodesByType(nodeType: NodeType): Node[] {\n    const results: Node[] = [];\n    this.traverseNodes(this.root, (node) => {\n      if (node.type === nodeType) {\n        results.push(node);\n      }\n    });\n    return results;\n  }\n\n  /**\n   * Get all nodes in the scene\n   */\n  getAllNodes(): Node[] {\n    return Array.from(this.nodeMap.values());\n  }\n\n  /**\n   * Traverse all nodes in the tree with a callback\n   */\n  traverseNodes(startNode: Node, callback: (node: Node) => void): void {\n    callback(startNode);\n    for (const child of startNode.children) {\n      this.traverseNodes(child, callback);\n    }\n  }\n\n  /**\n   * Get visible nodes for rendering (depth-first traversal)\n   */\n  getVisibleNodes(): Node[] {\n    const visibleNodes: Node[] = [];\n    this.collectVisibleNodes(this.root, visibleNodes);\n    return visibleNodes;\n  }\n\n  private collectVisibleNodes(node: Node, result: Node[]): void {\n    if (node.visible) {\n      result.push(node);\n      for (const child of node.children) {\n        this.collectVisibleNodes(child, result);\n      }\n    }\n  }\n\n  /**\n   * Build internal node map for fast lookups\n   */\n  private buildNodeMap(node: Node): void {\n    this.nodeMap.set(node.id, node);\n    for (const child of node.children) {\n      this.buildNodeMap(child);\n    }\n  }\n\n  /**\n   * Add node and its children to the node map\n   */\n  private addToNodeMap(node: Node): void {\n    this.nodeMap.set(node.id, node);\n    for (const child of node.children) {\n      this.addToNodeMap(child);\n    }\n  }\n\n  /**\n   * Remove node and its children from the node map\n   */\n  private removeFromNodeMap(node: Node): void {\n    this.nodeMap.delete(node.id);\n    for (const child of node.children) {\n      this.removeFromNodeMap(child);\n    }\n  }\n}\n\n/**\n * Factory functions for creating core node types\n */\nexport class NodeFactory {\n  /**\n   * Create a Group node (container for other nodes)\n   */\n  static createGroup(id: string): Node {\n    return new NodeImpl(id, 'Group');\n  }\n\n  /**\n   * Create a Sprite node for image rendering\n   */\n  static createSprite(id: string, spriteId?: string): Node {\n    const node = new NodeImpl(id, 'Sprite');\n    if (spriteId) {\n      // Store sprite reference in a way that can be accessed by renderer\n      (node as any).spriteId = spriteId;\n    }\n    return node;\n  }\n\n  /**\n   * Create a Text node for text rendering\n   */\n  static createText(id: string, text?: string): Node {\n    const node = new NodeImpl(id, 'Text');\n    if (text !== undefined) {\n      (node as any).text = text;\n    }\n    return node;\n  }\n\n  /**\n   * Create a Button node for interactive elements\n   */\n  static createButton(id: string, text?: string): Node {\n    const node = new NodeImpl(id, 'Button');\n    if (text !== undefined) {\n      (node as any).text = text;\n    }\n    return node;\n  }\n\n  /**\n   * Create a Camera2D node for viewport control\n   */\n  static createCamera2D(id: string): Node {\n    const node = new NodeImpl(id, 'Camera2D');\n    // Initialize camera-specific properties\n    (node as any).zoom = 1;\n    (node as any).target = { x: 0, y: 0 };\n    return node;\n  }\n}","/**\n * Fixed-tick game loop with interpolation for the LLM Canvas Engine\n * Provides deterministic 60Hz updates with smooth rendering interpolation\n */\n\nexport interface GameLoopCallbacks {\n  onTick?: (tick: number, deltaTime: number) => void;\n  onRender?: (interpolation: number, frameTime: number) => void;\n}\n\nexport interface PerformanceMetrics {\n  fps: number;\n  averageFrameTime: number;\n  tickRate: number;\n  droppedFrames: number;\n  totalTicks: number;\n  totalFrames: number;\n}\n\nexport interface SeededRNG {\n  seed(value: number): void;\n  random(): number;\n  randomInt(min: number, max: number): number;\n  randomFloat(min: number, max: number): number;\n}\n\n/**\n * Seedable pseudo-random number generator using Linear Congruential Generator\n * Provides deterministic random numbers for reproducible gameplay\n */\nclass DeterministicRNG implements SeededRNG {\n  private _seed: number = 1;\n\n  seed(value: number): void {\n    this._seed = Math.abs(value) || 1;\n  }\n\n  random(): number {\n    // LCG formula: (a * seed + c) % m\n    // Using values from Numerical Recipes\n    this._seed = (this._seed * 1664525 + 1013904223) % 4294967296;\n    return this._seed / 4294967296;\n  }\n\n  randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min + 1)) + min;\n  }\n\n  randomFloat(min: number, max: number): number {\n    return this.random() * (max - min) + min;\n  }\n}\n\n/**\n * Fixed-tick game loop with frame interpolation\n * Maintains deterministic 60Hz game logic updates while allowing smooth rendering\n */\nexport class GameLoop {\n  public readonly tickRate: number = 60; // 60 Hz fixed tick rate\n  public readonly tickInterval: number = 1000 / 60; // ~16.67ms per tick\n  \n  private _running: boolean = false;\n  private _paused: boolean = false;\n  private _callbacks: GameLoopCallbacks = {};\n  \n  // Timing state\n  private _lastTime: number = 0;\n  private _accumulator: number = 0;\n  private _tickCount: number = 0;\n  private _frameCount: number = 0;\n  \n  // Performance tracking\n  private _frameTimeHistory: number[] = [];\n  private _lastFpsUpdate: number = 0;\n  private _currentFps: number = 0;\n  private _droppedFrames: number = 0;\n  \n  // RNG system\n  private _rng: DeterministicRNG = new DeterministicRNG();\n  \n  // Animation frame handle\n  private _rafHandle: number | null = null;\n\n  constructor(callbacks?: GameLoopCallbacks) {\n    this._callbacks = callbacks || {};\n    this._rng.seed(Date.now());\n  }\n\n  /**\n   * Start the game loop\n   */\n  start(): void {\n    if (this._running) return;\n    \n    this._running = true;\n    this._paused = false;\n    this._lastTime = performance.now();\n    this._startTime = this._lastTime;\n    this._accumulator = 0;\n    this._tickCount = 0;\n    this._frameCount = 0;\n    this._droppedFrames = 0;\n    this._frameTimeHistory = [];\n    this._lastFpsUpdate = this._lastTime;\n    \n    this._gameLoopStep();\n  }\n\n  /**\n   * Stop the game loop\n   */\n  stop(): void {\n    this._running = false;\n    this._paused = false;\n    \n    if (this._rafHandle !== null) {\n      cancelAnimationFrame(this._rafHandle);\n      this._rafHandle = null;\n    }\n  }\n\n  /**\n   * Pause the game loop (stops ticks but continues rendering)\n   */\n  pause(): void {\n    this._paused = true;\n  }\n\n  /**\n   * Resume the game loop\n   */\n  resume(): void {\n    if (!this._running) return;\n    \n    this._paused = false;\n    this._lastTime = performance.now();\n    this._accumulator = 0; // Reset accumulator to prevent catch-up\n  }\n\n  /**\n   * Set callbacks for tick and render events\n   */\n  setCallbacks(callbacks: GameLoopCallbacks): void {\n    this._callbacks = { ...this._callbacks, ...callbacks };\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    const averageFrameTime = this._frameTimeHistory.length > 0\n      ? this._frameTimeHistory.reduce((a, b) => a + b, 0) / this._frameTimeHistory.length\n      : 0;\n\n    return {\n      fps: this._currentFps,\n      averageFrameTime,\n      tickRate: this.tickRate,\n      droppedFrames: this._droppedFrames,\n      totalTicks: this._tickCount,\n      totalFrames: this._frameCount\n    };\n  }\n\n  /**\n   * Get the deterministic RNG instance\n   */\n  getRNG(): SeededRNG {\n    return this._rng;\n  }\n\n  /**\n   * Seed the RNG for deterministic behavior\n   */\n  seedRNG(seed: number): void {\n    this._rng.seed(seed);\n  }\n\n  /**\n   * Get current tick count\n   */\n  get tickCount(): number {\n    return this._tickCount;\n  }\n\n  /**\n   * Get current frame count\n   */\n  get frameCount(): number {\n    return this._frameCount;\n  }\n\n  /**\n   * Check if the loop is running\n   */\n  get isRunning(): boolean {\n    return this._running;\n  }\n\n  /**\n   * Check if the loop is paused\n   */\n  get isPaused(): boolean {\n    return this._paused;\n  }\n\n  /**\n   * Main game loop step\n   */\n  private _gameLoopStep = (): void => {\n    if (!this._running) return;\n\n    const currentTime = performance.now();\n    const frameTime = currentTime - this._lastTime;\n    this._lastTime = currentTime;\n    this._frameCount++;\n\n    // Track frame time for performance metrics\n    this._frameTimeHistory.push(frameTime);\n    if (this._frameTimeHistory.length > 60) {\n      this._frameTimeHistory.shift();\n    }\n\n    // Update FPS counter every second\n    if (currentTime - this._lastFpsUpdate >= 1000) {\n      this._currentFps = Math.round(1000 / (this._frameTimeHistory.reduce((a, b) => a + b, 0) / this._frameTimeHistory.length));\n      this._lastFpsUpdate = currentTime;\n    }\n\n    // Fixed timestep with accumulator\n    if (!this._paused) {\n      this._accumulator += frameTime;\n\n      // Prevent spiral of death - if we're too far behind, drop frames\n      const maxAccumulator = this.tickInterval * 5; // Allow up to 5 ticks per frame\n      if (this._accumulator > maxAccumulator) {\n        const droppedTime = this._accumulator - maxAccumulator;\n        const droppedTicks = Math.floor(droppedTime / this.tickInterval);\n        this._droppedFrames += droppedTicks;\n        this._accumulator = maxAccumulator;\n      }\n\n      // Process fixed timestep updates\n      while (this._accumulator >= this.tickInterval) {\n        this._tick();\n        this._accumulator -= this.tickInterval;\n        this._tickCount++;\n      }\n    }\n\n    // Calculate interpolation factor for smooth rendering\n    const interpolation = this._paused ? 0 : this._accumulator / this.tickInterval;\n\n    // Render with interpolation\n    this._render(interpolation, frameTime);\n\n    // Schedule next frame\n    this._rafHandle = requestAnimationFrame(this._gameLoopStep);\n  };\n\n  /**\n   * Execute a single game logic tick\n   */\n  private _tick(): void {\n    if (this._callbacks.onTick) {\n      this._callbacks.onTick(this._tickCount, this.tickInterval);\n    }\n  }\n\n  /**\n   * Execute a render frame with interpolation\n   */\n  private _render(interpolation: number, frameTime: number): void {\n    if (this._callbacks.onRender) {\n      this._callbacks.onRender(interpolation, frameTime);\n    }\n  }\n}","/**\n * Mode-7 rendering module for fake-3D plane effects\n * Implements perspective transformation math for retro-style racing games\n */\n\nimport { Node, Vector2 } from '../types/core.js';\nimport { RenderModule, RenderContext, ModuleDefinition, Mode7PlaneNode } from '../types/modules.js';\nimport { ModuleRegistry } from '../core/module-registry.js';\n\n/**\n * Mode-7 specific node data\n */\nexport interface Mode7PlaneData {\n  texture: string;\n  horizon: number;      // Y position of horizon line (0-1, where 0.5 is center)\n  scale: number;        // Scale factor for texture mapping\n  offset: Vector2;      // Texture offset for scrolling\n  textureWidth: number; // Width of texture in pixels\n  textureHeight: number; // Height of texture in pixels\n}\n\n/**\n * Mode-7 camera parameters\n */\nexport interface Mode7Camera {\n  position: Vector2;    // World position\n  rotation: number;     // Camera rotation in radians\n  height: number;       // Camera height above ground plane\n  pitch: number;        // Camera pitch angle in radians\n  fov: number;          // Field of view in radians\n}\n\n/**\n * Mode-7 transformation math utilities\n */\nexport class Mode7Math {\n  /**\n   * Transform screen coordinates to world coordinates using Mode-7 perspective\n   */\n  static screenToWorld(\n    screenX: number, \n    screenY: number, \n    camera: Mode7Camera, \n    viewport: { width: number; height: number; horizon: number }\n  ): Vector2 {\n    const { width, height, horizon } = viewport;\n    \n    // Convert screen coordinates to normalized coordinates\n    const normalizedX = (screenX - width / 2) / (width / 2);\n    const horizonY = height * horizon;\n    \n    // Skip horizon line to avoid division by zero\n    if (Math.abs(screenY - horizonY) < 0.001) {\n      return { x: camera.position.x, y: camera.position.y };\n    }\n    \n    // Calculate distance from camera based on Y position and camera height\n    // Points below horizon are closer, points at horizon are infinitely far\n    const screenDistanceFromHorizon = screenY - horizonY;\n    const distance = camera.height / (screenDistanceFromHorizon / height * Math.tan(camera.pitch));\n    \n    // Calculate world position relative to camera\n    const relativeX = distance * normalizedX;\n    const relativeY = distance;\n    \n    // Rotate by camera rotation and translate by camera position\n    const worldX = camera.position.x + relativeX * Math.cos(camera.rotation) - relativeY * Math.sin(camera.rotation);\n    const worldY = camera.position.y + relativeX * Math.sin(camera.rotation) + relativeY * Math.cos(camera.rotation);\n    \n    return { x: worldX, y: worldY };\n  }\n\n  /**\n   * Transform world coordinates to screen coordinates using Mode-7 perspective\n   */\n  static worldToScreen(\n    worldX: number, \n    worldY: number, \n    camera: Mode7Camera, \n    viewport: { width: number; height: number; horizon: number }\n  ): Vector2 {\n    const { width, height, horizon } = viewport;\n    \n    // Translate world coordinates relative to camera\n    const relativeX = worldX - camera.position.x;\n    const relativeY = worldY - camera.position.y;\n    \n    // Rotate by camera rotation\n    const rotatedX = relativeX * Math.cos(-camera.rotation) - relativeY * Math.sin(-camera.rotation);\n    const rotatedY = relativeX * Math.sin(-camera.rotation) + relativeY * Math.cos(-camera.rotation);\n    \n    // Skip points behind camera or at camera position\n    if (rotatedY <= 0.001) {\n      return { x: -1, y: -1 }; // Off-screen marker\n    }\n    \n    // Apply perspective projection\n    const projectedX = rotatedX / rotatedY;\n    const screenDistanceFromHorizon = camera.height / (rotatedY * Math.tan(camera.pitch));\n    \n    // Convert to screen coordinates\n    const screenX = width / 2 + projectedX * (width / 2);\n    const screenY = height * horizon + screenDistanceFromHorizon * height;\n    \n    return { x: screenX, y: screenY };\n  }\n\n  /**\n   * Calculate texture coordinates for a world position\n   */\n  static getTextureCoordinates(\n    worldPos: Vector2, \n    textureSize: Vector2, \n    scale: number, \n    offset: Vector2\n  ): Vector2 {\n    const u = (worldPos.x * scale + offset.x) % textureSize.x;\n    const v = (worldPos.y * scale + offset.y) % textureSize.y;\n    \n    // Handle negative modulo\n    return {\n      x: u < 0 ? u + textureSize.x : u,\n      y: v < 0 ? v + textureSize.y : v\n    };\n  }\n\n  /**\n   * Create a default Mode-7 camera\n   */\n  static createDefaultCamera(): Mode7Camera {\n    return {\n      position: { x: 0, y: 0 },\n      rotation: 0,\n      height: 100,\n      pitch: Math.PI / 6, // 30 degrees\n      fov: Math.PI / 3    // 60 degrees\n    };\n  }\n}\n\n/**\n * Mode-7 render module implementation\n */\nexport class Mode7RenderModule implements RenderModule {\n  name = 'mode7';\n  nodeTypes = ['Mode7Plane'];\n  \n  private textureCache = new Map<string, HTMLImageElement>();\n  private defaultCamera: Mode7Camera;\n\n  constructor() {\n    this.defaultCamera = Mode7Math.createDefaultCamera();\n  }\n\n  render(node: Node, context: RenderContext): void {\n    const mode7Node = node as Mode7PlaneNode;\n    const mode7Data = this.getMode7Data(mode7Node);\n    \n    if (!mode7Data) {\n      console.warn('Mode7Plane node missing required data');\n      return;\n    }\n\n    // Get or create Mode-7 camera from scene\n    const mode7Camera = this.getMode7Camera(context) || this.defaultCamera;\n    \n    // Load texture\n    const texture = this.getTexture(mode7Data.texture);\n    if (!texture) {\n      this.renderPlaceholder(context, mode7Data);\n      return;\n    }\n\n    // Render Mode-7 plane\n    const mode7Viewport = {\n      width: context.viewport.width,\n      height: context.viewport.height,\n      horizon: mode7Data.horizon\n    };\n    this.renderMode7Plane(context, mode7Data, mode7Camera, texture, mode7Viewport);\n  }\n\n  private getMode7Data(node: Mode7PlaneNode): Mode7PlaneData | null {\n    // Extract Mode-7 specific data from node\n    const data = node as any;\n    \n    if (!data.texture) {\n      return null;\n    }\n\n    return {\n      texture: data.texture,\n      horizon: data.horizon ?? 0.5,\n      scale: data.scale ?? 1.0,\n      offset: data.offset ?? { x: 0, y: 0 },\n      textureWidth: data.textureWidth ?? 256,\n      textureHeight: data.textureHeight ?? 256\n    };\n  }\n\n  private getMode7Camera(context: RenderContext): Mode7Camera | null {\n    // Look for Mode-7 camera data in the render context\n    // This would be set by Mode-7 specific actions\n    return (context as any).mode7Camera || null;\n  }\n\n  private getTexture(textureId: string): HTMLImageElement | null {\n    // Check cache first\n    if (this.textureCache.has(textureId)) {\n      return this.textureCache.get(textureId)!;\n    }\n\n    // For now, return null - in a full implementation, this would load the texture\n    // TODO: Integrate with asset loading system\n    return null;\n  }\n\n  private renderPlaceholder(context: RenderContext, data: Mode7PlaneData): void {\n    const { ctx, viewport } = context;\n    const horizonY = viewport.height * data.horizon;\n    \n    // Draw a simple gradient as placeholder\n    const gradient = ctx.createLinearGradient(0, horizonY, 0, viewport.height);\n    gradient.addColorStop(0, '#87CEEB'); // Sky blue\n    gradient.addColorStop(1, '#228B22'); // Forest green\n    \n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, horizonY, viewport.width, viewport.height - horizonY);\n    \n    // Draw horizon line\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(0, horizonY);\n    ctx.lineTo(viewport.width, horizonY);\n    ctx.stroke();\n  }\n\n  private renderMode7Plane(\n    context: RenderContext, \n    data: Mode7PlaneData, \n    camera: Mode7Camera, \n    texture: HTMLImageElement,\n    mode7Viewport: { width: number; height: number; horizon: number }\n  ): void {\n    const { ctx } = context;\n    const horizonY = mode7Viewport.height * data.horizon;\n    \n    // Create image data for pixel-by-pixel rendering\n    const imageData = ctx.createImageData(mode7Viewport.width, mode7Viewport.height - horizonY);\n    const pixels = imageData.data;\n    \n    // Create canvas for texture sampling\n    const textureCanvas = document.createElement('canvas');\n    textureCanvas.width = texture.width;\n    textureCanvas.height = texture.height;\n    const textureCtx = textureCanvas.getContext('2d')!;\n    textureCtx.drawImage(texture, 0, 0);\n    const textureData = textureCtx.getImageData(0, 0, texture.width, texture.height);\n    \n    // Render each scanline\n    for (let y = 0; y < mode7Viewport.height - horizonY; y++) {\n      const screenY = horizonY + y;\n      this.renderScanline(\n        pixels, \n        y, \n        screenY, \n        mode7Viewport.width, \n        data, \n        camera, \n        mode7Viewport, \n        textureData\n      );\n    }\n    \n    // Draw the rendered plane\n    ctx.putImageData(imageData, 0, horizonY);\n  }\n\n  private renderScanline(\n    pixels: Uint8ClampedArray,\n    scanlineIndex: number,\n    screenY: number,\n    width: number,\n    data: Mode7PlaneData,\n    camera: Mode7Camera,\n    viewport: { width: number; height: number; horizon: number },\n    textureData: ImageData\n  ): void {\n    const baseIndex = scanlineIndex * width * 4;\n    \n    for (let x = 0; x < width; x++) {\n      // Transform screen coordinates to world coordinates\n      const worldPos = Mode7Math.screenToWorld(x, screenY, camera, viewport);\n      \n      // Get texture coordinates\n      const texCoords = Mode7Math.getTextureCoordinates(\n        worldPos,\n        { x: data.textureWidth, y: data.textureHeight },\n        data.scale,\n        data.offset\n      );\n      \n      // Sample texture\n      const color = this.sampleTexture(textureData, texCoords.x, texCoords.y);\n      \n      // Set pixel color\n      const pixelIndex = baseIndex + x * 4;\n      pixels[pixelIndex] = color.r;     // Red\n      pixels[pixelIndex + 1] = color.g; // Green\n      pixels[pixelIndex + 2] = color.b; // Blue\n      pixels[pixelIndex + 3] = 255;     // Alpha\n    }\n  }\n\n  private sampleTexture(\n    textureData: ImageData, \n    u: number, \n    v: number\n  ): { r: number; g: number; b: number } {\n    const x = Math.floor(u) % textureData.width;\n    const y = Math.floor(v) % textureData.height;\n    const index = (y * textureData.width + x) * 4;\n    \n    return {\n      r: textureData.data[index],\n      g: textureData.data[index + 1],\n      b: textureData.data[index + 2]\n    };\n  }\n}\n\n/**\n * Mode-7 module definition for registration\n */\nexport const Mode7ModuleDefinition: ModuleDefinition = {\n  name: 'mode7',\n  nodeTypes: ['Mode7Plane'],\n  actions: ['setMode7Camera', 'moveMode7Camera'],\n  triggers: [],\n  dependencies: [],\n  size: 8 // Estimated KB\n};\n\n/**\n * Register the Mode-7 module\n */\nexport function registerMode7Module(): void {\n  const registry = ModuleRegistry.getInstance();\n  \n  // Register module definition\n  registry.registerModule(Mode7ModuleDefinition);\n  \n  // Register render module\n  const renderModule = new Mode7RenderModule();\n  registry.registerRenderModule(renderModule);\n  \n  // Register action handlers\n  registry.registerActionHandler('setMode7Camera', (params: any) => {\n    // TODO: Implement Mode-7 camera action handler\n    console.log('setMode7Camera action:', params);\n  });\n  \n  registry.registerActionHandler('moveMode7Camera', (params: any) => {\n    // TODO: Implement Mode-7 camera movement action handler\n    console.log('moveMode7Camera action:', params);\n  });\n}","/**\n * Particles system module for 2D particle effects\n * Implements particle lifecycle management, physics, and rendering\n */\n\nimport { Node } from '../types/core.js';\nimport { RenderModule, RenderContext, ModuleDefinition, Particles2DNode, ParticleEmitter, Particle } from '../types/modules.js';\nimport { ModuleRegistry } from '../core/module-registry.js';\n\n/**\n * Particle system manager for a single emitter\n */\nexport class ParticleSystem {\n  private particles: Particle[] = [];\n  private nextParticleId = 0;\n  private emissionAccumulator = 0;\n\n  constructor(\n    private emitter: ParticleEmitter,\n    private maxParticles: number\n  ) {}\n\n  /**\n   * Update particle system - spawn new particles and update existing ones\n   */\n  update(deltaTime: number): void {\n    // Update existing particles\n    this.updateParticles(deltaTime);\n\n    // Remove dead particles\n    this.removeDeadParticles();\n\n    // Spawn new particles if emitter is enabled\n    if (this.emitter.enabled && this.particles.length < this.maxParticles) {\n      this.spawnParticles(deltaTime);\n    }\n  }\n\n  /**\n   * Get all active particles\n   */\n  getParticles(): Particle[] {\n    return this.particles;\n  }\n\n  /**\n   * Start emitting particles\n   */\n  startEmit(): void {\n    this.emitter.enabled = true;\n  }\n\n  /**\n   * Stop emitting particles\n   */\n  stopEmit(): void {\n    this.emitter.enabled = false;\n  }\n\n  /**\n   * Emit a burst of particles\n   */\n  burstEmit(count: number): void {\n    for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {\n      this.spawnParticle();\n    }\n  }\n\n  /**\n   * Clear all particles\n   */\n  clear(): void {\n    this.particles.length = 0;\n  }\n\n  /**\n   * Update emitter configuration\n   */\n  updateEmitter(emitter: Partial<ParticleEmitter>): void {\n    Object.assign(this.emitter, emitter);\n  }\n\n  private updateParticles(deltaTime: number): void {\n    for (const particle of this.particles) {\n      // Update age\n      particle.age += deltaTime;\n\n      // Update physics\n      particle.velocity.x += particle.acceleration.x * deltaTime;\n      particle.velocity.y += particle.acceleration.y * deltaTime;\n      particle.position.x += particle.velocity.x * deltaTime;\n      particle.position.y += particle.velocity.y * deltaTime;\n\n      // Update rotation\n      particle.rotation += particle.rotationSpeed * deltaTime;\n\n      // Update lifetime-based properties\n      const lifetimeRatio = particle.age / particle.maxLifetime;\n      \n      // Interpolate alpha if end alpha is specified\n      if (particle.alphaEnd !== undefined) {\n        particle.alpha = this.lerp(particle.alpha, particle.alphaEnd, lifetimeRatio);\n      }\n\n      // Interpolate color if end color is specified\n      if (particle.colorEnd) {\n        particle.color = this.lerpColor(particle.color, particle.colorEnd, lifetimeRatio);\n      }\n    }\n  }\n\n  private removeDeadParticles(): void {\n    this.particles = this.particles.filter(particle => particle.age < particle.maxLifetime);\n  }\n\n  private spawnParticles(deltaTime: number): void {\n    // Only spawn if rate is greater than 0\n    if (this.emitter.rate <= 0) {\n      return;\n    }\n\n    // Accumulate emission time\n    this.emissionAccumulator += deltaTime * this.emitter.rate;\n\n    // Spawn particles based on accumulated time\n    while (this.emissionAccumulator >= 1 && this.particles.length < this.maxParticles) {\n      this.spawnParticle();\n      this.emissionAccumulator -= 1;\n    }\n  }\n\n  private spawnParticle(): void {\n    // Calculate lifetime with variance\n    const lifetime = this.emitter.lifetime + \n      (Math.random() - 0.5) * 2 * this.emitter.lifetimeVariance;\n\n    // Calculate initial velocity with variance\n    const velocity = {\n      x: this.emitter.velocity.x + (Math.random() - 0.5) * 2 * this.emitter.velocityVariance.x,\n      y: this.emitter.velocity.y + (Math.random() - 0.5) * 2 * this.emitter.velocityVariance.y\n    };\n\n    // Calculate initial scale with variance\n    const scale = this.emitter.scale + (Math.random() - 0.5) * 2 * this.emitter.scaleVariance;\n\n    const particle: Particle = {\n      id: this.nextParticleId++,\n      position: { ...this.emitter.position },\n      velocity,\n      acceleration: { ...this.emitter.acceleration },\n      scale: Math.max(0.1, scale), // Ensure minimum scale\n      rotation: this.emitter.rotation,\n      rotationSpeed: this.emitter.rotationSpeed,\n      color: this.emitter.color,\n      colorEnd: this.emitter.colorEnd,\n      alpha: this.emitter.alpha,\n      alphaEnd: this.emitter.alphaEnd,\n      lifetime: Math.max(0.1, lifetime), // Ensure minimum lifetime\n      maxLifetime: Math.max(0.1, lifetime),\n      age: 0\n    };\n\n    this.particles.push(particle);\n  }\n\n  private lerp(start: number, end: number, t: number): number {\n    return start + (end - start) * Math.min(1, Math.max(0, t));\n  }\n\n  private lerpColor(startColor: string, endColor: string, t: number): string {\n    // Simple color interpolation - in a full implementation, this would handle RGB/HSL properly\n    // For now, return the start color\n    return t > 0.5 ? endColor : startColor;\n  }\n}\n\n/**\n * Particles render module implementation\n */\nexport class ParticlesRenderModule implements RenderModule {\n  name = 'particles';\n  nodeTypes = ['Particles2D'];\n  \n  private particleSystems = new Map<string, ParticleSystem>();\n  private textureCache = new Map<string, HTMLImageElement>();\n\n  render(node: Node, context: RenderContext): void {\n    const particlesNode = node as Particles2DNode;\n    \n    // Get or create particle system for this node\n    let particleSystem = this.particleSystems.get(node.id);\n    if (!particleSystem) {\n      particleSystem = new ParticleSystem(particlesNode.emitter, particlesNode.maxParticles);\n      this.particleSystems.set(node.id, particleSystem);\n    }\n\n    // Update particle system\n    const deltaTime = 1 / 60; // Fixed timestep - in full implementation, get from game loop\n    particleSystem.update(deltaTime);\n\n    // Render particles\n    this.renderParticles(particleSystem.getParticles(), particlesNode, context);\n  }\n\n  /**\n   * Handle particle actions\n   */\n  handleAction(nodeId: string, action: string, params: any): void {\n    let particleSystem = this.particleSystems.get(nodeId);\n    \n    // Create particle system if it doesn't exist for certain actions\n    if (!particleSystem && (action === 'startEmit' || action === 'burstEmit')) {\n      // Create a default particle system\n      const defaultEmitter = {\n        position: { x: 0, y: 0 },\n        rate: 10,\n        lifetime: 1.0,\n        lifetimeVariance: 0,\n        velocity: { x: 0, y: 0 },\n        velocityVariance: { x: 0, y: 0 },\n        acceleration: { x: 0, y: 0 },\n        scale: 1.0,\n        scaleVariance: 0,\n        rotation: 0,\n        rotationSpeed: 0,\n        color: '#ffffff',\n        alpha: 1.0,\n        enabled: true\n      };\n      particleSystem = new ParticleSystem(defaultEmitter, 100);\n      this.particleSystems.set(nodeId, particleSystem);\n    }\n    \n    if (!particleSystem) {\n      console.warn(`No particle system found for node ${nodeId}`);\n      return;\n    }\n\n    switch (action) {\n      case 'startEmit':\n        particleSystem.startEmit();\n        break;\n      case 'stopEmit':\n        particleSystem.stopEmit();\n        break;\n      case 'burstEmit':\n        particleSystem.burstEmit(params.count || 10);\n        break;\n      default:\n        console.warn(`Unknown particle action: ${action}`);\n    }\n  }\n\n  /**\n   * Clean up particle system for a node\n   */\n  cleanup(nodeId: string): void {\n    this.particleSystems.delete(nodeId);\n  }\n\n  private renderParticles(particles: Particle[], node: Particles2DNode, context: RenderContext): void {\n    const { ctx } = context;\n    \n    // Set blend mode\n    const oldCompositeOperation = ctx.globalCompositeOperation;\n    if (node.blendMode) {\n      switch (node.blendMode) {\n        case 'additive':\n          ctx.globalCompositeOperation = 'lighter';\n          break;\n        case 'multiply':\n          ctx.globalCompositeOperation = 'multiply';\n          break;\n        default:\n          ctx.globalCompositeOperation = 'source-over';\n      }\n    }\n\n    // Render each particle\n    for (const particle of particles) {\n      this.renderParticle(particle, node, context);\n    }\n\n    // Restore blend mode\n    ctx.globalCompositeOperation = oldCompositeOperation;\n  }\n\n  private renderParticle(particle: Particle, node: Particles2DNode, context: RenderContext): void {\n    const { ctx } = context;\n    \n    ctx.save();\n\n    // Apply particle transform\n    ctx.translate(particle.position.x, particle.position.y);\n    ctx.rotate(particle.rotation);\n    ctx.scale(particle.scale, particle.scale);\n    ctx.globalAlpha = particle.alpha;\n\n    if (node.texture) {\n      // Render with texture\n      const texture = this.getTexture(node.texture);\n      if (texture) {\n        ctx.drawImage(texture, -texture.width / 2, -texture.height / 2);\n      } else {\n        // Fallback to colored rectangle\n        this.renderColoredParticle(particle, ctx);\n      }\n    } else {\n      // Render as colored shape\n      this.renderColoredParticle(particle, ctx);\n    }\n\n    ctx.restore();\n  }\n\n  private renderColoredParticle(particle: Particle, ctx: CanvasRenderingContext2D): void {\n    const size = 4; // Base particle size\n    \n    ctx.fillStyle = particle.color;\n    ctx.beginPath();\n    ctx.arc(0, 0, size, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private getTexture(textureId: string): HTMLImageElement | null {\n    // Check cache first\n    if (this.textureCache.has(textureId)) {\n      return this.textureCache.get(textureId)!;\n    }\n\n    // For now, return null - in a full implementation, this would load the texture\n    // TODO: Integrate with asset loading system\n    return null;\n  }\n}\n\n/**\n * Particles module definition for registration\n */\nexport const ParticlesModuleDefinition: ModuleDefinition = {\n  name: 'particles',\n  nodeTypes: ['Particles2D'],\n  actions: ['startEmit', 'stopEmit', 'burstEmit'],\n  triggers: [],\n  dependencies: [],\n  size: 6 // Estimated KB\n};\n\n/**\n * Register the particles module\n */\nexport function registerParticlesModule(): void {\n  const registry = ModuleRegistry.getInstance();\n  \n  // Register module definition\n  registry.registerModule(ParticlesModuleDefinition);\n  \n  // Register render module\n  const renderModule = new ParticlesRenderModule();\n  registry.registerRenderModule(renderModule);\n  \n  // Register action handlers\n  registry.registerActionHandler('startEmit', (params: any, context: any) => {\n    if (context.nodeId) {\n      renderModule.handleAction(context.nodeId, 'startEmit', params);\n    }\n  });\n  \n  registry.registerActionHandler('stopEmit', (params: any, context: any) => {\n    if (context.nodeId) {\n      renderModule.handleAction(context.nodeId, 'stopEmit', params);\n    }\n  });\n  \n  registry.registerActionHandler('burstEmit', (params: any, context: any) => {\n    if (context.nodeId) {\n      renderModule.handleAction(context.nodeId, 'burstEmit', params);\n    }\n  });\n}","/**\n * Action and Trigger execution system\n */\n\nimport { Action, Condition } from '../types/actions.js';\nimport { Node, LGFCartridge, AudioManager } from '../types/core.js';\nimport { GameLoop } from './game-loop.js';\n\nexport interface ActionContext {\n  node: Node;\n  cartridge: LGFCartridge;\n  gameLoop: GameLoop;\n  audioManager: AudioManager;\n  variables: Map<string, any>;\n  currentScene: string;\n  sceneNodes: Map<string, Node>;\n}\n\nexport interface TweenTarget {\n  object: any;\n  property: string;\n  startValue: number;\n  endValue: number;\n  duration: number;\n  elapsed: number;\n  easing: EasingFunction;\n}\n\nexport type EasingFunction = (t: number) => number;\n\nexport class ActionSystem {\n  private tweens: Map<string, TweenTarget> = new Map();\n  private timers: Map<string, Timer> = new Map();\n  private nextTweenId = 0;\n  private nextTimerId = 0;\n\n  constructor() {}\n\n  /**\n   * Execute an action with the given context\n   */\n  async executeAction(action: Action, context: ActionContext): Promise<void> {\n    // Check conditions first\n    if (action.conditions && !this.evaluateConditions(action.conditions, context)) {\n      return;\n    }\n\n    switch (action.type) {\n      case 'gotoScene':\n        this.executeGotoScene(action, context);\n        break;\n      case 'spawn':\n        this.executeSpawn(action, context);\n        break;\n      case 'despawn':\n        this.executeDespawn(action, context);\n        break;\n      case 'setVar':\n        this.executeSetVar(action, context);\n        break;\n      case 'incVar':\n        this.executeIncVar(action, context);\n        break;\n      case 'randomInt':\n        this.executeRandomInt(action, context);\n        break;\n      case 'if':\n        this.executeIf(action, context);\n        break;\n      case 'tween':\n        this.executeTween(action, context);\n        break;\n      case 'startTimer':\n        this.executeStartTimer(action, context);\n        break;\n      case 'stopTimer':\n        this.executeStopTimer(action, context);\n        break;\n      case 'playSfx':\n        this.executePlaySfx(action, context);\n        break;\n      case 'playMusic':\n        this.executePlayMusic(action, context);\n        break;\n      case 'stopMusic':\n        this.executeStopMusic(action, context);\n        break;\n      default:\n        console.warn(`Unsupported action type: ${action.type}`);\n    }\n  }\n\n  /**\n   * Update all active tweens and timers\n   */\n  update(deltaTime: number): void {\n    this.updateTweens(deltaTime);\n    this.updateTimers(deltaTime);\n  }\n\n  /**\n   * Evaluate conditions for an action\n   */\n  private evaluateConditions(conditions: Condition[], context: ActionContext): boolean {\n    return conditions.every(condition => this.evaluateCondition(condition, context));\n  }\n\n  /**\n   * Evaluate a single condition\n   */\n  private evaluateCondition(condition: Condition, context: ActionContext): boolean {\n    const variable = context.variables.get(condition.variable);\n    \n    switch (condition.type) {\n      case 'equals':\n        return variable === condition.value;\n      case 'greater':\n        return typeof variable === 'number' && variable > (condition.value || 0);\n      case 'less':\n        return typeof variable === 'number' && variable < (condition.value || 0);\n      case 'exists':\n        return variable !== undefined;\n      default:\n        return false;\n    }\n  }\n\n  // Action implementations\n  private executeGotoScene(action: Action, context: ActionContext): void {\n    const sceneId = action.params.scene;\n    if (typeof sceneId === 'string') {\n      // This would trigger a scene change in the engine\n      context.variables.set('__nextScene', sceneId);\n    }\n  }\n\n  private executeSpawn(action: Action, context: ActionContext): void {\n    const nodeData = action.params.node;\n    const parentId = action.params.parent || context.node.id;\n    \n    if (nodeData && typeof nodeData === 'object') {\n      // Create new node from data\n      const newNode = this.createNodeFromData(nodeData);\n      const parent = context.sceneNodes.get(parentId);\n      \n      if (parent && newNode) {\n        parent.addChild(newNode);\n        context.sceneNodes.set(newNode.id, newNode);\n      }\n    }\n  }\n\n  private executeDespawn(action: Action, context: ActionContext): void {\n    const nodeId = action.params.node || context.node.id;\n    const node = context.sceneNodes.get(nodeId);\n    \n    if (node) {\n      node.removeFromParent();\n      context.sceneNodes.delete(nodeId);\n    }\n  }\n\n  private executeSetVar(action: Action, context: ActionContext): void {\n    const variable = action.params.variable;\n    const value = action.params.value;\n    \n    if (typeof variable === 'string') {\n      context.variables.set(variable, value);\n    }\n  }\n\n  private executeIncVar(action: Action, context: ActionContext): void {\n    const variable = action.params.variable;\n    const amount = action.params.amount || 1;\n    \n    if (typeof variable === 'string') {\n      const current = context.variables.get(variable) || 0;\n      if (typeof current === 'number') {\n        context.variables.set(variable, current + amount);\n      }\n    }\n  }\n\n  private executeRandomInt(action: Action, context: ActionContext): void {\n    const min = action.params.min || 0;\n    const max = action.params.max || 100;\n    const variable = action.params.variable;\n    \n    if (typeof variable === 'string') {\n      const value = context.gameLoop.getRNG().randomInt(min, max);\n      context.variables.set(variable, value);\n    }\n  }\n\n  private executeIf(action: Action, context: ActionContext): void {\n    const condition = action.params.condition;\n    const thenActions = action.params.then || [];\n    const elseActions = action.params.else || [];\n    \n    if (condition && this.evaluateCondition(condition, context)) {\n      // Execute then actions\n      for (const thenAction of thenActions) {\n        this.executeAction(thenAction, context);\n      }\n    } else {\n      // Execute else actions\n      for (const elseAction of elseActions) {\n        this.executeAction(elseAction, context);\n      }\n    }\n  }\n\n  private executeTween(action: Action, context: ActionContext): void {\n    const target = action.params.target || context.node;\n    const property = action.params.property;\n    const to = action.params.to;\n    const duration = action.params.duration || 1000; // ms\n    const easing = this.getEasingFunction(action.params.easing || 'linear');\n    \n    if (!target || !property || to === undefined) {\n      return;\n    }\n\n    const startValue = this.getPropertyValue(target, property);\n    if (typeof startValue !== 'number' || typeof to !== 'number') {\n      return;\n    }\n\n    const tweenId = `tween_${this.nextTweenId++}`;\n    const tween: TweenTarget = {\n      object: target,\n      property,\n      startValue,\n      endValue: to,\n      duration,\n      elapsed: 0,\n      easing\n    };\n\n    this.tweens.set(tweenId, tween);\n  }\n\n  private executeStartTimer(action: Action, context: ActionContext): void {\n    const duration = action.params.duration || 1000; // ms\n    const actions = action.params.actions || [];\n    const timerId = action.params.id || `timer_${this.nextTimerId++}`;\n    \n    const timer: Timer = {\n      id: timerId,\n      duration,\n      elapsed: 0,\n      actions,\n      context\n    };\n    \n    this.timers.set(timerId, timer);\n  }\n\n  private executeStopTimer(action: Action, _context: ActionContext): void {\n    const timerId = action.params.id;\n    if (typeof timerId === 'string') {\n      this.timers.delete(timerId);\n    }\n  }\n\n  private executePlaySfx(action: Action, context: ActionContext): void {\n    const id = action.params.id;\n    const volume = action.params.volume;\n    \n    if (typeof id === 'string') {\n      context.audioManager.playSfx(id, volume);\n    }\n  }\n\n  private executePlayMusic(action: Action, context: ActionContext): void {\n    const id = action.params.id;\n    const loop = action.params.loop;\n    const volume = action.params.volume;\n    \n    if (typeof id === 'string') {\n      context.audioManager.playMusic(id, loop, volume);\n    }\n  }\n\n  private executeStopMusic(_action: Action, context: ActionContext): void {\n    context.audioManager.stopMusic();\n  }\n\n  // Helper methods\n  private createNodeFromData(_nodeData: any): Node | null {\n    // This would create a proper Node instance from JSON data\n    // For now, return null as this requires the full Node implementation\n    return null;\n  }\n\n  private getPropertyValue(object: any, property: string): any {\n    const parts = property.split('.');\n    let current = object;\n    \n    for (const part of parts) {\n      if (current && typeof current === 'object' && part in current) {\n        current = current[part];\n      } else {\n        return undefined;\n      }\n    }\n    \n    return current;\n  }\n\n  private setPropertyValue(object: any, property: string, value: any): void {\n    const parts = property.split('.');\n    let current = object;\n    \n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      if (current && typeof current === 'object' && part in current) {\n        current = current[part];\n      } else {\n        return;\n      }\n    }\n    \n    const finalPart = parts[parts.length - 1];\n    if (current && typeof current === 'object') {\n      current[finalPart] = value;\n    }\n  }\n\n  private getEasingFunction(easing: string): EasingFunction {\n    switch (easing) {\n      case 'linear':\n        return (t: number) => t;\n      case 'easeIn':\n        return (t: number) => t * t;\n      case 'easeOut':\n        return (t: number) => 1 - (1 - t) * (1 - t);\n      case 'easeInOut':\n        return (t: number) => t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);\n      default:\n        return (t: number) => t;\n    }\n  }\n\n  private updateTweens(deltaTime: number): void {\n    const completedTweens: string[] = [];\n\n    for (const [id, tween] of this.tweens) {\n      tween.elapsed += deltaTime;\n      const progress = Math.min(tween.elapsed / tween.duration, 1);\n      const easedProgress = tween.easing(progress);\n      \n      const currentValue = tween.startValue + (tween.endValue - tween.startValue) * easedProgress;\n      this.setPropertyValue(tween.object, tween.property, currentValue);\n      \n      if (progress >= 1) {\n        completedTweens.push(id);\n      }\n    }\n\n    // Remove completed tweens\n    for (const id of completedTweens) {\n      this.tweens.delete(id);\n    }\n  }\n\n  private updateTimers(deltaTime: number): void {\n    const completedTimers: string[] = [];\n\n    for (const [id, timer] of this.timers) {\n      timer.elapsed += deltaTime;\n      \n      if (timer.elapsed >= timer.duration) {\n        // Execute timer actions\n        for (const action of timer.actions) {\n          this.executeAction(action, timer.context);\n        }\n        completedTimers.push(id);\n      }\n    }\n\n    // Remove completed timers\n    for (const id of completedTimers) {\n      this.timers.delete(id);\n    }\n  }\n}\n\ninterface Timer {\n  id: string;\n  duration: number;\n  elapsed: number;\n  actions: Action[];\n  context: ActionContext;\n}","/**\n * Integration layer between InputManager and TriggerSystem\n * This bridges the new InputManager with the existing trigger system\n */\n\nimport { InputManager } from '../types/core.js';\nimport { TriggerSystem, InputEvent } from './trigger-system.js';\nimport { ActionContext } from './action-system.js';\n\nexport class InputIntegration {\n  private inputManager: InputManager;\n  private triggerSystem: TriggerSystem;\n  private previousKeyStates = new Map<string, boolean>();\n  private previousPointerStates = new Map<number, boolean>();\n\n  constructor(inputManager: InputManager, triggerSystem: TriggerSystem) {\n    this.inputManager = inputManager;\n    this.triggerSystem = triggerSystem;\n  }\n\n  /**\n   * Update input integration - should be called each frame\n   * This checks for input state changes and forwards them to the trigger system\n   */\n  update(context: ActionContext): void {\n    this.checkKeyStateChanges(context);\n    this.checkPointerStateChanges(context);\n  }\n\n  /**\n   * Set up common input mappings for accessibility and navigation\n   */\n  setupDefaultMappings(): void {\n    // Navigation keys\n    this.inputManager.mapKey('up', 'nav-up');\n    this.inputManager.mapKey('down', 'nav-down');\n    this.inputManager.mapKey('left', 'nav-left');\n    this.inputManager.mapKey('right', 'nav-right');\n    \n    // Action keys\n    this.inputManager.mapKey('space', 'primary-action');\n    this.inputManager.mapKey('enter', 'confirm');\n    this.inputManager.mapKey('escape', 'cancel');\n    this.inputManager.mapKey('tab', 'next');\n    \n    // WASD movement\n    this.inputManager.mapKey('w', 'move-up');\n    this.inputManager.mapKey('a', 'move-left');\n    this.inputManager.mapKey('s', 'move-down');\n    this.inputManager.mapKey('d', 'move-right');\n    \n    // Pointer mappings\n    this.inputManager.mapPointer(0, 'primary-click'); // Left click\n    this.inputManager.mapPointer(2, 'secondary-click'); // Right click\n  }\n\n  /**\n   * Check for key state changes and forward to trigger system\n   */\n  private checkKeyStateChanges(context: ActionContext): void {\n    // List of keys to monitor (could be expanded or made configurable)\n    const keysToMonitor = [\n      'space', 'enter', 'escape', 'tab',\n      'up', 'down', 'left', 'right',\n      'w', 'a', 's', 'd',\n      'shift', 'ctrl', 'alt'\n    ];\n\n    for (const key of keysToMonitor) {\n      const wasPressed = this.previousKeyStates.get(key) || false;\n      const isPressed = this.inputManager.isActionPressed(this.getActionForKey(key));\n      \n      if (isPressed !== wasPressed) {\n        const inputEvent: InputEvent = {\n          type: 'key',\n          key: key,\n          pressed: isPressed\n        };\n        \n        this.triggerSystem.handleInput(inputEvent, context);\n        this.previousKeyStates.set(key, isPressed);\n      }\n    }\n  }\n\n  /**\n   * Check for pointer state changes and forward to trigger system\n   */\n  private checkPointerStateChanges(context: ActionContext): void {\n    const buttonsToMonitor = [0, 1, 2]; // Left, middle, right\n\n    for (const button of buttonsToMonitor) {\n      const wasPressed = this.previousPointerStates.get(button) || false;\n      const isPressed = this.inputManager.isActionPressed(this.getActionForPointer(button));\n      \n      if (isPressed !== wasPressed) {\n        const inputEvent: InputEvent = {\n          type: 'pointer',\n          button: button,\n          position: this.inputManager.getPointerPosition(),\n          pressed: isPressed\n        };\n        \n        this.triggerSystem.handleInput(inputEvent, context);\n        this.previousPointerStates.set(button, isPressed);\n      }\n    }\n  }\n\n  /**\n   * Get the action name for a key (based on default mappings)\n   */\n  private getActionForKey(key: string): string {\n    const keyActionMap: Record<string, string> = {\n      'up': 'nav-up',\n      'down': 'nav-down',\n      'left': 'nav-left',\n      'right': 'nav-right',\n      'space': 'primary-action',\n      'enter': 'confirm',\n      'escape': 'cancel',\n      'tab': 'next',\n      'w': 'move-up',\n      'a': 'move-left',\n      's': 'move-down',\n      'd': 'move-right'\n    };\n    \n    return keyActionMap[key] || key;\n  }\n\n  /**\n   * Get the action name for a pointer button\n   */\n  private getActionForPointer(button: number): string {\n    const buttonActionMap: Record<number, string> = {\n      0: 'primary-click',\n      1: 'middle-click',\n      2: 'secondary-click'\n    };\n    \n    return buttonActionMap[button] || `button-${button}`;\n  }\n\n  /**\n   * Check if a specific action is currently pressed\n   */\n  isActionPressed(action: string): boolean {\n    return this.inputManager.isActionPressed(action);\n  }\n\n  /**\n   * Check if a specific action was just pressed this frame\n   */\n  isActionJustPressed(action: string): boolean {\n    return this.inputManager.isActionJustPressed(action);\n  }\n\n  /**\n   * Check if a specific action was just released this frame\n   */\n  isActionJustReleased(action: string): boolean {\n    return this.inputManager.isActionJustReleased(action);\n  }\n\n  /**\n   * Get current pointer position\n   */\n  getPointerPosition() {\n    return this.inputManager.getPointerPosition();\n  }\n}","/**\n * Optimized canvas rendering system for the LLM Canvas Engine\n */\n\nimport { Node, ThemeTokens, Vector2, Transform2D } from '../types/core.js';\nimport { RenderModule, RenderContext, Camera2D, Viewport } from '../types/modules.js';\nimport { ModuleRegistry } from './module-registry.js';\nimport { PerformanceMonitor, QualitySettings } from './performance-monitor.js';\nimport { MemoryManager } from './memory-manager.js';\nimport { AccessibilityManager } from './accessibility-manager.js';\n\nexport interface RenderStats {\n  drawCalls: number;\n  triangles: number;\n  sprites: number;\n  renderTime: number;\n  culledNodes: number;\n  batchedSprites: number;\n}\n\n/**\n * Optimized canvas renderer with performance monitoring and quality adjustment\n */\nexport class Renderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private offscreenCanvas?: HTMLCanvasElement;\n  private offscreenCtx?: CanvasRenderingContext2D;\n  private theme: ThemeTokens;\n  private camera: Camera2D;\n  private viewport: Viewport;\n  private modules = new Map<string, RenderModule>();\n  private nodeTypeToModule = new Map<string, RenderModule>();\n  private performanceMonitor?: PerformanceMonitor;\n  private memoryManager?: MemoryManager;\n  private accessibilityManager?: AccessibilityManager;\n  private qualitySettings: QualitySettings = {\n    renderScale: 1.0,\n    particleDensity: 1.0,\n    shadowQuality: 'medium',\n    textureFiltering: true,\n    postProcessing: true,\n    audioQuality: 'high',\n    maxActiveAudioSources: 8\n  };\n  private renderStats: RenderStats = {\n    drawCalls: 0,\n    triangles: 0,\n    sprites: 0,\n    renderTime: 0,\n    culledNodes: 0,\n    batchedSprites: 0\n  };\n  private spriteBatch: any[] = [];\n  private enableFrustumCulling = true;\n  private enableSpriteBatching = true;\n\n  constructor(canvas: HTMLCanvasElement, theme: ThemeTokens) {\n    this.canvas = canvas;\n    const ctx = canvas.getContext('2d', {\n      alpha: false, // Opaque canvas for better performance\n      desynchronized: true, // Allow async rendering\n      willReadFrequently: false // Optimize for write-only\n    });\n    if (!ctx) {\n      throw new Error('Failed to get 2D rendering context');\n    }\n    this.ctx = ctx;\n    this.theme = theme;\n    \n    // Initialize camera\n    this.camera = {\n      position: { x: 0, y: 0 },\n      zoom: 1,\n      rotation: 0,\n      target: { x: 0, y: 0 }\n    };\n\n    // Initialize viewport\n    this.viewport = {\n      width: canvas.width,\n      height: canvas.height,\n      scale: 1,\n      offset: { x: 0, y: 0 }\n    };\n\n    // Setup optimization features\n    this.setupOffscreenCanvas();\n    this.optimizeCanvasSettings();\n    this.detectPlatformOptimizations();\n\n    // Register core node type renderers\n    this.registerCoreRenderers();\n    \n    // Load any registered render modules from the module registry\n    this.loadRegisteredModules();\n    \n    // Set up responsive canvas\n    this.setupResponsiveCanvas();\n  }\n\n  /**\n   * Main render method - renders scene tree with interpolation and optimizations\n   */\n  render(sceneTree: Node[], interpolation: number): void {\n    const startTime = performance.now();\n    \n    // Reset render stats\n    this.renderStats = {\n      drawCalls: 0,\n      triangles: 0,\n      sprites: 0,\n      renderTime: 0,\n      culledNodes: 0,\n      batchedSprites: 0\n    };\n\n    // Choose rendering context based on quality settings\n    const renderCtx = this.qualitySettings.renderScale < 1.0 && this.offscreenCtx \n      ? this.offscreenCtx \n      : this.ctx;\n    const renderCanvas = this.qualitySettings.renderScale < 1.0 && this.offscreenCanvas \n      ? this.offscreenCanvas \n      : this.canvas;\n\n    // Clear canvas\n    renderCtx.clearRect(0, 0, renderCanvas.width, renderCanvas.height);\n    this.renderStats.drawCalls++;\n    \n    // Fill background\n    renderCtx.fillStyle = this.theme.colors.background;\n    renderCtx.fillRect(0, 0, renderCanvas.width, renderCanvas.height);\n    this.renderStats.drawCalls++;\n\n    // Set up camera transform\n    this.setupCameraTransform(interpolation, renderCtx);\n\n    // Create render context\n    const context: RenderContext = {\n      canvas: renderCanvas,\n      ctx: renderCtx,\n      camera: this.camera,\n      theme: this.theme,\n      interpolation,\n      viewport: this.viewport\n    };\n\n    // Cull and batch nodes for optimized rendering\n    const visibleNodes = this.cullNodes(sceneTree);\n    \n    // Render with batching optimizations\n    this.renderOptimized(visibleNodes, context);\n\n    // Copy from offscreen canvas if using scaled rendering\n    if (renderCtx !== this.ctx && this.offscreenCanvas) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.ctx.drawImage(\n        this.offscreenCanvas, \n        0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height,\n        0, 0, this.canvas.width, this.canvas.height\n      );\n      this.renderStats.drawCalls++;\n    }\n\n    // Reset transform\n    renderCtx.restore();\n\n    // Update render stats\n    this.renderStats.renderTime = performance.now() - startTime;\n    \n    // Report to performance monitor\n    if (this.performanceMonitor) {\n      this.performanceMonitor.updateMetrics(\n        this.renderStats.renderTime,\n        this.getMemoryUsage(),\n        this.renderStats.sprites,\n        this.renderStats.drawCalls\n      );\n    }\n  }\n\n  /**\n   * Register a render module for custom node types\n   */\n  registerModule(module: RenderModule): void {\n    this.modules.set(module.name, module);\n    \n    // Map node types to this module\n    for (const nodeType of module.nodeTypes) {\n      this.nodeTypeToModule.set(nodeType, module);\n    }\n\n    // Also register with the module registry\n    ModuleRegistry.getInstance().registerRenderModule(module);\n  }\n\n  /**\n   * Update theme tokens\n   */\n  setTheme(theme: ThemeTokens): void {\n    this.theme = theme;\n    \n    // Update accessibility manager with new theme\n    if (this.accessibilityManager) {\n      this.accessibilityManager.setTheme(theme);\n    }\n  }\n\n  /**\n   * Update camera properties\n   */\n  setCamera(camera: Partial<Camera2D>): void {\n    Object.assign(this.camera, camera);\n  }\n\n  /**\n   * Get current viewport information\n   */\n  getViewport(): Viewport {\n    return { ...this.viewport };\n  }\n\n  /**\n   * Convert screen coordinates to world coordinates\n   */\n  screenToWorld(screenPos: Vector2): Vector2 {\n    const worldX = (screenPos.x - this.viewport.offset.x) / this.camera.zoom + this.camera.position.x;\n    const worldY = (screenPos.y - this.viewport.offset.y) / this.camera.zoom + this.camera.position.y;\n    return { x: worldX, y: worldY };\n  }\n\n  /**\n   * Convert world coordinates to screen coordinates\n   */\n  worldToScreen(worldPos: Vector2): Vector2 {\n    const screenX = (worldPos.x - this.camera.position.x) * this.camera.zoom + this.viewport.offset.x;\n    const screenY = (worldPos.y - this.camera.position.y) * this.camera.zoom + this.viewport.offset.y;\n    return { x: screenX, y: screenY };\n  }\n\n  private setupCameraTransform(): void {\n    this.ctx.save();\n    \n    // Apply viewport scaling and centering\n    this.ctx.translate(this.viewport.offset.x, this.viewport.offset.y);\n    this.ctx.scale(this.viewport.scale, this.viewport.scale);\n    \n    // Apply camera transform\n    this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\n    this.ctx.scale(this.camera.zoom, this.camera.zoom);\n    this.ctx.rotate(this.camera.rotation);\n    this.ctx.translate(-this.camera.position.x, -this.camera.position.y);\n  }\n\n  private renderNode(node: Node, context: RenderContext): void {\n    // Get interpolated world transform\n    const worldTransform = this.getInterpolatedWorldTransform(node);\n    \n    // Skip if completely transparent\n    if (worldTransform.alpha <= 0) {\n      return;\n    }\n\n    // Save context state\n    context.ctx.save();\n\n    // Apply node transform\n    this.applyTransform(context.ctx, worldTransform);\n\n    // Render based on node type\n    const module = this.nodeTypeToModule.get(node.type);\n    if (module) {\n      module.render(node, context);\n    } else {\n      console.warn(`No renderer found for node type: ${node.type}`);\n    }\n\n    // Render children\n    for (const child of node.children) {\n      if (child.visible) {\n        this.renderNode(child, context);\n      }\n    }\n\n    // Restore context state\n    context.ctx.restore();\n  }\n\n  private getInterpolatedWorldTransform(node: Node): Transform2D {\n    // For now, return current world transform\n    // In a full implementation, this would interpolate between previous and current transforms\n    return node.getWorldTransform();\n  }\n\n  private applyTransform(ctx: CanvasRenderingContext2D, transform: Transform2D): void {\n    ctx.translate(transform.position.x, transform.position.y);\n    ctx.rotate(transform.rotation);\n    ctx.scale(transform.scale.x, transform.scale.y);\n    \n    // Apply skew if present\n    if (transform.skew.x !== 0 || transform.skew.y !== 0) {\n      ctx.transform(1, Math.tan(transform.skew.y), Math.tan(transform.skew.x), 1, 0, 0);\n    }\n    \n    ctx.globalAlpha *= transform.alpha;\n  }\n\n  private registerCoreRenderers(): void {\n    // Register core node type renderers\n    const coreRenderer: RenderModule = {\n      name: 'core',\n      nodeTypes: ['Group', 'Sprite', 'Text', 'Button', 'Camera2D'],\n      render: (node: Node, context: RenderContext) => {\n        this.renderCoreNode(node, context);\n      }\n    };\n\n    this.registerModule(coreRenderer);\n  }\n\n  private renderCoreNode(node: Node, context: RenderContext): void {\n    switch (node.type) {\n      case 'Group':\n        // Groups don't render anything themselves, just their children\n        break;\n        \n      case 'Sprite':\n        this.renderSprite(node, context);\n        break;\n        \n      case 'Text':\n        this.renderText(node, context);\n        break;\n        \n      case 'Button':\n        this.renderButton(node, context);\n        break;\n        \n      case 'Camera2D':\n        // Camera nodes don't render visually\n        break;\n        \n      default:\n        console.warn(`Core renderer doesn't handle node type: ${node.type}`);\n    }\n  }\n\n  private renderSprite(node: Node, context: RenderContext): void {\n    const spriteId = (node as any).spriteId;\n    if (!spriteId) {\n      // Render placeholder rectangle\n      context.ctx.fillStyle = context.theme.colors.primary;\n      context.ctx.fillRect(-25, -25, 50, 50);\n      return;\n    }\n\n    // TODO: Load and render actual sprite image\n    // For now, render a colored rectangle as placeholder\n    context.ctx.fillStyle = context.theme.colors.primary;\n    context.ctx.fillRect(-25, -25, 50, 50);\n  }\n\n  private renderText(node: Node, context: RenderContext): void {\n    const text = (node as any).text || 'Text';\n    let fontSize = (node as any).fontSize || context.theme.font.sizes.medium || 16;\n    \n    // Apply accessibility text scaling\n    if (this.accessibilityManager) {\n      fontSize = Math.round(fontSize * this.accessibilityManager.getTextScaling());\n    }\n    \n    context.ctx.font = `${fontSize}px ${context.theme.font.family}`;\n    context.ctx.fillStyle = context.theme.colors.text;\n    context.ctx.textAlign = 'center';\n    context.ctx.textBaseline = 'middle';\n    \n    context.ctx.fillText(text, 0, 0);\n  }\n\n  private renderButton(node: Node, context: RenderContext): void {\n    const text = (node as any).text || 'Button';\n    let fontSize = (node as any).fontSize || context.theme.font.sizes.medium || 16;\n    const padding = context.theme.spacing.medium || 8;\n    \n    // Apply accessibility text scaling\n    if (this.accessibilityManager) {\n      fontSize = Math.round(fontSize * this.accessibilityManager.getTextScaling());\n    }\n    \n    // Check if this button is currently focused\n    const isFocused = this.accessibilityManager?.getCurrentFocus()?.id === node.id;\n    \n    // Measure text\n    context.ctx.font = `${fontSize}px ${context.theme.font.family}`;\n    const textMetrics = context.ctx.measureText(text);\n    const textWidth = textMetrics.width;\n    const textHeight = fontSize;\n    \n    // Calculate button dimensions (ensure minimum 44px for accessibility)\n    const minSize = 44;\n    const buttonWidth = Math.max(textWidth + padding * 2, minSize);\n    const buttonHeight = Math.max(textHeight + padding * 2, minSize);\n    \n    // Draw button background\n    context.ctx.fillStyle = isFocused ? context.theme.colors.accent : context.theme.colors.secondary;\n    const radius = context.theme.radii.small || 4;\n    this.drawRoundedRect(context.ctx, -buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, radius);\n    \n    // Draw focus indicator if focused\n    if (isFocused) {\n      context.ctx.strokeStyle = context.theme.colors.primary;\n      context.ctx.lineWidth = 2;\n      context.ctx.setLineDash([4, 2]);\n      this.strokeRoundedRect(context.ctx, -buttonWidth/2 - 2, -buttonHeight/2 - 2, buttonWidth + 4, buttonHeight + 4, radius + 2);\n      context.ctx.setLineDash([]);\n    }\n    \n    // Draw button text\n    context.ctx.fillStyle = context.theme.colors.text;\n    context.ctx.textAlign = 'center';\n    context.ctx.textBaseline = 'middle';\n    context.ctx.fillText(text, 0, 0);\n  }\n\n  private drawRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private strokeRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number): void {\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  private loadRegisteredModules(): void {\n    const moduleRegistry = ModuleRegistry.getInstance();\n    const registeredModules = moduleRegistry.getRegisteredModules();\n    \n    for (const moduleDefinition of registeredModules) {\n      const renderModule = moduleRegistry.getRenderModule(moduleDefinition.name);\n      if (renderModule) {\n        this.modules.set(renderModule.name, renderModule);\n        \n        // Map node types to this module\n        for (const nodeType of renderModule.nodeTypes) {\n          this.nodeTypeToModule.set(nodeType, renderModule);\n        }\n      }\n    }\n  }\n\n  private setupResponsiveCanvas(): void {\n    const updateViewport = () => {\n      const container = this.canvas.parentElement;\n      if (!container) return;\n\n      const containerRect = container.getBoundingClientRect();\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      \n      // Calculate scale to fit container while maintaining aspect ratio\n      const canvasAspect = this.canvas.width / this.canvas.height;\n      const containerAspect = containerRect.width / containerRect.height;\n      \n      let scale: number;\n      if (canvasAspect > containerAspect) {\n        // Canvas is wider - fit to width\n        scale = containerRect.width / this.canvas.width;\n      } else {\n        // Canvas is taller - fit to height\n        scale = containerRect.height / this.canvas.height;\n      }\n\n      // Update viewport\n      this.viewport = {\n        width: this.canvas.width,\n        height: this.canvas.height,\n        scale: scale * devicePixelRatio,\n        offset: {\n          x: (containerRect.width - this.canvas.width * scale) / 2,\n          y: (containerRect.height - this.canvas.height * scale) / 2\n        }\n      };\n\n      // Update canvas display size\n      this.canvas.style.width = `${this.canvas.width * scale}px`;\n      this.canvas.style.height = `${this.canvas.height * scale}px`;\n    };\n\n    // Update on resize\n    window.addEventListener('resize', updateViewport);\n    updateViewport();\n  }\n\n  // Performance optimization methods\n\n  private setupOffscreenCanvas(): void {\n    try {\n      this.offscreenCanvas = document.createElement('canvas');\n      this.offscreenCanvas.width = this.canvas.width;\n      this.offscreenCanvas.height = this.canvas.height;\n      this.offscreenCtx = this.offscreenCanvas.getContext('2d', {\n        alpha: false,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n    } catch (error) {\n      console.warn('Offscreen canvas not available:', error);\n    }\n  }\n\n  private optimizeCanvasSettings(): void {\n    // Disable image smoothing for pixel-perfect rendering when needed\n    this.ctx.imageSmoothingEnabled = this.qualitySettings.textureFiltering;\n    if (this.offscreenCtx) {\n      this.offscreenCtx.imageSmoothingEnabled = this.qualitySettings.textureFiltering;\n    }\n\n    // Set optimal composite operation\n    this.ctx.globalCompositeOperation = 'source-over';\n  }\n\n  private detectPlatformOptimizations(): void {\n    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    const isLowEnd = this.detectLowEndDevice();\n\n    if (isMobile || isLowEnd) {\n      this.qualitySettings.renderScale = 0.8;\n      this.qualitySettings.particleDensity = 0.7;\n      this.qualitySettings.textureFiltering = false;\n      this.qualitySettings.postProcessing = false;\n      this.maxBatchSize = 50;\n      this.enableFrustumCulling = true;\n      this.enableSpriteBatching = true;\n    }\n  }\n\n  private detectLowEndDevice(): boolean {\n    const memory = (navigator as any).deviceMemory;\n    const cores = navigator.hardwareConcurrency;\n    \n    if (memory && memory < 4) return true; // Less than 4GB RAM\n    if (cores && cores < 4) return true; // Less than 4 CPU cores\n    \n    return false;\n  }\n\n\n  private cullNodes(nodes: Node[]): Node[] {\n    if (!this.enableFrustumCulling) {\n      return nodes.filter(node => node.visible && node.isWorldVisible());\n    }\n\n    const visibleNodes: Node[] = [];\n    const frustum = this.calculateFrustum();\n\n    for (const node of nodes) {\n      if (node.visible && node.isWorldVisible()) {\n        if (this.isNodeInFrustum(node, frustum)) {\n          visibleNodes.push(node);\n        } else {\n          this.renderStats.culledNodes++;\n        }\n      }\n    }\n\n    return visibleNodes;\n  }\n\n  private calculateFrustum(): { left: number; right: number; top: number; bottom: number } {\n    const halfWidth = this.canvas.width / (2 * this.camera.zoom);\n    const halfHeight = this.canvas.height / (2 * this.camera.zoom);\n    \n    return {\n      left: this.camera.position.x - halfWidth,\n      right: this.camera.position.x + halfWidth,\n      top: this.camera.position.y - halfHeight,\n      bottom: this.camera.position.y + halfHeight\n    };\n  }\n\n  private isNodeInFrustum(node: Node, frustum: { left: number; right: number; top: number; bottom: number }): boolean {\n    const worldTransform = node.getWorldTransform();\n    const bounds = this.getNodeBounds(node, worldTransform);\n    \n    return !(\n      bounds.right < frustum.left ||\n      bounds.left > frustum.right ||\n      bounds.bottom < frustum.top ||\n      bounds.top > frustum.bottom\n    );\n  }\n\n  private getNodeBounds(node: Node, transform: Transform2D): { left: number; right: number; top: number; bottom: number } {\n    // Simplified bounds calculation - in a full implementation this would be more sophisticated\n    const size = 50; // Default node size\n    const halfSize = size / 2;\n    \n    return {\n      left: transform.position.x - halfSize,\n      right: transform.position.x + halfSize,\n      top: transform.position.y - halfSize,\n      bottom: transform.position.y + halfSize\n    };\n  }\n\n  private renderOptimized(nodes: Node[], context: RenderContext): void {\n    if (this.enableSpriteBatching) {\n      this.renderWithBatching(nodes, context);\n    } else {\n      // Fallback to regular rendering\n      for (const node of nodes) {\n        this.renderNode(node, context);\n      }\n    }\n  }\n\n  private renderWithBatching(nodes: Node[], context: RenderContext): void {\n    // Collect sprites for batching\n    this.spriteBatch = [];\n    const nonBatchableNodes: Node[] = [];\n\n    for (const node of nodes) {\n      if (node.type === 'Sprite' && this.canBatchSprite(node)) {\n        this.spriteBatch.push(node);\n      } else {\n        nonBatchableNodes.push(node);\n      }\n    }\n\n    // Render batched sprites\n    if (this.spriteBatch.length > 0) {\n      this.renderSpriteBatch(context);\n    }\n\n    // Render non-batchable nodes\n    for (const node of nonBatchableNodes) {\n      this.renderNode(node, context);\n    }\n  }\n\n  private canBatchSprite(node: Node): boolean {\n    const transform = node.getWorldTransform();\n    \n    // Only batch sprites with simple transforms\n    return (\n      transform.rotation === 0 &&\n      transform.skew.x === 0 &&\n      transform.skew.y === 0 &&\n      transform.alpha === 1\n    );\n  }\n\n  private renderSpriteBatch(context: RenderContext): void {\n    if (this.spriteBatch.length === 0) return;\n\n    context.ctx.save();\n\n    // Sort sprites by texture/color for better batching\n    this.spriteBatch.sort((a, b) => {\n      const aSprite = a as any;\n      const bSprite = b as any;\n      return (aSprite.texture || aSprite.color || '').localeCompare(bSprite.texture || bSprite.color || '');\n    });\n\n    // Render all sprites in batch\n    let currentTexture = '';\n    for (const node of this.spriteBatch) {\n      const sprite = node as any;\n      const transform = node.getWorldTransform();\n      \n      // Change fill style only when texture/color changes\n      const texture = sprite.texture || sprite.color || context.theme.colors.primary;\n      if (texture !== currentTexture) {\n        context.ctx.fillStyle = texture;\n        currentTexture = texture;\n      }\n\n      // Render sprite\n      const size = 50; // Default sprite size\n      context.ctx.fillRect(\n        transform.position.x - size/2, \n        transform.position.y - size/2, \n        size * transform.scale.x, \n        size * transform.scale.y\n      );\n      \n      this.renderStats.sprites++;\n      this.renderStats.batchedSprites++;\n    }\n\n    context.ctx.restore();\n    this.renderStats.drawCalls++;\n  }\n\n  private getMemoryUsage(): number {\n    if (this.memoryManager) {\n      return this.memoryManager.getCurrentMemoryUsage() / 1024 / 1024; // Convert to MB\n    }\n    \n    if ('memory' in performance) {\n      return (performance as any).memory.usedJSHeapSize / 1024 / 1024;\n    }\n    \n    return 0;\n  }\n\n  // Public optimization methods\n\n  setPerformanceMonitor(monitor: PerformanceMonitor): void {\n    this.performanceMonitor = monitor;\n    \n    // Listen for quality changes\n    monitor.setCallbacks({\n      onQualityChange: (settings) => {\n        this.updateQualitySettings(settings);\n      }\n    });\n  }\n\n  setMemoryManager(manager: MemoryManager): void {\n    this.memoryManager = manager;\n  }\n\n  setAccessibilityManager(manager: AccessibilityManager): void {\n    this.accessibilityManager = manager;\n  }\n\n  private updateQualitySettings(settings: QualitySettings): void {\n    this.qualitySettings = settings;\n    \n    // Apply render scale\n    if (settings.renderScale !== 1.0 && this.offscreenCanvas) {\n      const scaledWidth = Math.floor(this.canvas.width * settings.renderScale);\n      const scaledHeight = Math.floor(this.canvas.height * settings.renderScale);\n      \n      this.offscreenCanvas.width = scaledWidth;\n      this.offscreenCanvas.height = scaledHeight;\n    }\n\n    // Update texture filtering\n    this.ctx.imageSmoothingEnabled = settings.textureFiltering;\n    if (this.offscreenCtx) {\n      this.offscreenCtx.imageSmoothingEnabled = settings.textureFiltering;\n    }\n\n    // Adjust batch size based on quality\n    this.maxBatchSize = Math.floor(100 * settings.particleDensity);\n  }\n\n  getRenderStats(): RenderStats {\n    return { ...this.renderStats };\n  }\n\n  optimizeForMobile(): void {\n    this.qualitySettings.renderScale = 0.75;\n    this.qualitySettings.textureFiltering = false;\n    this.qualitySettings.postProcessing = false;\n    this.maxBatchSize = 50;\n    this.enableFrustumCulling = true;\n    this.enableSpriteBatching = true;\n    \n    this.updateQualitySettings(this.qualitySettings);\n  }\n\n  getPerformanceRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const stats = this.renderStats;\n    \n    if (stats.drawCalls > 100) {\n      recommendations.push('High draw call count - consider sprite batching');\n    }\n    \n    if (stats.renderTime > 16) {\n      recommendations.push('Render time exceeds 16ms - reduce visual complexity');\n    }\n    \n    if (stats.sprites > 200) {\n      recommendations.push('Too many sprites - consider culling off-screen objects');\n    }\n\n    if (stats.culledNodes / (stats.sprites + stats.culledNodes) < 0.1) {\n      recommendations.push('Low culling efficiency - check frustum culling implementation');\n    }\n    \n    return recommendations;\n  }\n\n  resize(width: number, height: number): void {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    \n    if (this.offscreenCanvas) {\n      this.offscreenCanvas.width = Math.floor(width * this.qualitySettings.renderScale);\n      this.offscreenCanvas.height = Math.floor(height * this.qualitySettings.renderScale);\n    }\n    \n    this.optimizeCanvasSettings();\n  }\n}","/**\n * Trigger event system\n */\n\nimport { Trigger, TriggerEvent } from '../types/actions.js';\nimport { Node } from '../types/core.js';\nimport { ActionSystem, ActionContext } from './action-system.js';\n\nexport interface TriggerContext extends ActionContext {\n  eventData?: any;\n}\n\nexport interface InputEvent {\n  type: 'key' | 'pointer';\n  key?: string;\n  button?: number;\n  position?: { x: number; y: number };\n  pressed?: boolean;\n}\n\nexport class TriggerSystem {\n  private actionSystem: ActionSystem;\n  private activeNodes: Set<Node> = new Set();\n  private keyStates: Map<string, boolean> = new Map();\n  private pointerStates: Map<number, boolean> = new Map();\n  private timers: Map<string, number> = new Map();\n\n  constructor(actionSystem: ActionSystem) {\n    this.actionSystem = actionSystem;\n  }\n\n  /**\n   * Register a node for trigger processing\n   */\n  registerNode(node: Node, context?: ActionContext): void {\n    this.activeNodes.add(node);\n    \n    // Process on.start triggers immediately if context is provided\n    if (context) {\n      const startContext: TriggerContext = { ...context, node };\n      this.processTriggers(node, 'on.start', startContext);\n    }\n  }\n\n  /**\n   * Unregister a node from trigger processing\n   */\n  unregisterNode(node: Node): void {\n    this.activeNodes.delete(node);\n  }\n\n  /**\n   * Process tick triggers for all registered nodes\n   */\n  processTick(context: ActionContext): void {\n    for (const node of this.activeNodes) {\n      const tickContext: TriggerContext = { ...context, node };\n      this.processTriggers(node, 'on.tick', tickContext);\n    }\n  }\n\n  /**\n   * Handle input events and trigger appropriate actions\n   */\n  handleInput(event: InputEvent, context: ActionContext): void {\n    if (event.type === 'key') {\n      this.handleKeyEvent(event, context);\n    } else if (event.type === 'pointer') {\n      this.handlePointerEvent(event, context);\n    }\n  }\n\n  /**\n   * Process timer triggers\n   */\n  processTimers(context: ActionContext, deltaTime: number): void {\n    // Update timer states\n    for (const [timerId, remaining] of this.timers) {\n      const newRemaining = remaining - deltaTime;\n      \n      if (newRemaining <= 0) {\n        // Timer expired, trigger timer events\n        for (const node of this.activeNodes) {\n          const timerContext: TriggerContext = { \n            ...context, \n            node,\n            eventData: { timerId }\n          };\n          this.processTriggers(node, 'on.timer', timerContext);\n        }\n        this.timers.delete(timerId);\n      } else {\n        this.timers.set(timerId, newRemaining);\n      }\n    }\n  }\n\n  /**\n   * Start a timer that will trigger on.timer events\n   */\n  startTimer(id: string, duration: number): void {\n    this.timers.set(id, duration);\n  }\n\n  /**\n   * Stop a timer\n   */\n  stopTimer(id: string): void {\n    this.timers.delete(id);\n  }\n\n  /**\n   * Process triggers of a specific event type for a node\n   */\n  private processTriggers(node: Node, eventType: TriggerEvent, context?: TriggerContext): void {\n    if (!node.triggers || !context) return;\n\n    for (const trigger of node.triggers) {\n      if (trigger.event === eventType) {\n        // Execute all actions for this trigger\n        for (const action of trigger.actions) {\n          this.actionSystem.executeAction(action, context);\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle keyboard events\n   */\n  private handleKeyEvent(event: InputEvent, context: ActionContext): void {\n    if (!event.key) return;\n\n    const wasPressed = this.keyStates.get(event.key) || false;\n    const isPressed = event.pressed || false;\n    \n    this.keyStates.set(event.key, isPressed);\n\n    // Only trigger on key press (not release or hold)\n    if (isPressed && !wasPressed) {\n      for (const node of this.activeNodes) {\n        const keyContext: TriggerContext = {\n          ...context,\n          node,\n          eventData: { key: event.key }\n        };\n        \n        // Check if this node has key triggers for this specific key\n        if (node.triggers) {\n          for (const trigger of node.triggers) {\n            if (trigger.event === 'on.key') {\n              // Check if trigger is for this specific key or any key\n              const triggerKey = this.getTriggerKey(trigger);\n              if (!triggerKey || triggerKey === event.key) {\n                for (const action of trigger.actions) {\n                  this.actionSystem.executeAction(action, keyContext);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle pointer/mouse events\n   */\n  private handlePointerEvent(event: InputEvent, context: ActionContext): void {\n    const button = event.button || 0;\n    const wasPressed = this.pointerStates.get(button) || false;\n    const isPressed = event.pressed || false;\n    \n    this.pointerStates.set(button, isPressed);\n\n    // Only trigger on pointer press (not release or hold)\n    if (isPressed && !wasPressed) {\n      for (const node of this.activeNodes) {\n        // Check if pointer is over this node (simplified check)\n        if (this.isPointerOverNode(node, event.position)) {\n          const pointerContext: TriggerContext = {\n            ...context,\n            node,\n            eventData: { \n              button,\n              position: event.position\n            }\n          };\n          \n          this.processTriggers(node, 'on.pointer', pointerContext);\n        }\n      }\n    }\n  }\n\n  /**\n   * Extract the key from a key trigger (if specified)\n   */\n  private getTriggerKey(): string | null {\n    // Look for key specification in trigger actions or params\n    // This is a simplified implementation\n    return null;\n  }\n\n  /**\n   * Check if pointer position is over a node\n   * This is a simplified implementation - real implementation would need\n   * proper transform calculations and bounds checking\n   */\n  private isPointerOverNode(node: Node, position?: { x: number; y: number }): boolean {\n    if (!position || !node.visible) return false;\n    \n    // Simplified bounds check - real implementation would calculate\n    // world transform and proper bounds\n    const nodePos = node.transform.position;\n    const distance = Math.sqrt(\n      Math.pow(position.x - nodePos.x, 2) + \n      Math.pow(position.y - nodePos.y, 2)\n    );\n    \n    // Simple radius check - real implementation would use proper bounds\n    return distance < 50;\n  }\n\n  /**\n   * Get current key state\n   */\n  isKeyPressed(key: string): boolean {\n    return this.keyStates.get(key) || false;\n  }\n\n  /**\n   * Get current pointer button state\n   */\n  isPointerPressed(button: number = 0): boolean {\n    return this.pointerStates.get(button) || false;\n  }\n\n  /**\n   * Clear all input states (useful for scene transitions)\n   */\n  clearInputStates(): void {\n    this.keyStates.clear();\n    this.pointerStates.clear();\n  }\n}","/**\n * Main entry point for the LLM Canvas Engine\n */\n\nimport { LLMRTEngineImpl } from './core/engine.js';\nimport { ModuleRegistry } from './core/module-registry.js';\n\n// Export main engine class\nexport { LLMRTEngineImpl as LLMRTEngine };\n\n// Export module registry for module registration\nexport { ModuleRegistry };\n\n// Export all types\nexport * from './types/index.js';\n\n// Export validation system\nexport * from './core/validator.js';\n\n// Export asset management system\nexport * from './core/asset-manager.js';\n\n// Export cartridge loading system\nexport * from './core/cartridge-loader.js';\n\n// Export scene tree system\nexport * from './core/scene-tree.js';\n\n// Export game loop system\nexport * from './core/game-loop.js';\n\n// Export action and trigger systems\nexport * from './core/action-system.js';\nexport * from './core/trigger-system.js';\n\n// Export rendering system\nexport * from './core/renderer.js';\n\n// Export input management system\nexport * from './core/input-manager.js';\nexport * from './core/input-integration.js';\n\n// Export audio management system\nexport * from './core/audio-manager.js';\n\n// Export optional modules\nexport * from './modules/mode7.js';\nexport * from './modules/particles.js';\n\n// Factory function for creating engine instances\nexport function createEngine() {\n  return new LLMRTEngineImpl();\n}\n\n// Global registration functions for modules\nexport function registerModule(module: any) {\n  const registry = ModuleRegistry.getInstance();\n  registry.registerModule(module);\n}\n\nexport function registerRenderModule(renderModule: any) {\n  const registry = ModuleRegistry.getInstance();\n  registry.registerRenderModule(renderModule);\n}"],"names":["ModuleRegistry","constructor","this","modules","Map","renderModules","actionHandlers","triggerEvents","Set","getInstance","instance","registerModule","module","set","name","nodeTypes","forEach","_nodeType","actions","_action","triggers","trigger","add","registerRenderModule","renderModule","registerActionHandler","actionType","handler","getModule","get","getRenderModule","getRenderModulesForNodeType","nodeType","Array","from","values","filter","includes","getActionHandler","isRegisteredModule","has","getRegisteredModules","getRenderModules","getEstimatedSize","reduce","total","size","supportsNodeType","some","supportsTriggerEvent","event","InputManagerImpl","keyMappings","pointerMappings","actionStates","keyStates","canvas","frameCount","isInitialized","pointerState","position","x","y","worldPosition","buttons","boundKeyDown","handleKeyDown","bind","boundKeyUp","handleKeyUp","boundPointerDown","handlePointerDown","boundPointerUp","handlePointerUp","boundPointerMove","handlePointerMove","boundContextMenu","handleContextMenu","initialize","cleanup","document","addEventListener","tabIndex","style","outline","removeEventListener","mapKey","key","action","sanitizedKey","sanitizeKey","sanitizedAction","sanitizeAction","mapPointer","button","isActionPressed","state","pressed","isActionJustPressed","justPressed","isActionJustReleased","justReleased","getPointerPosition","getPointerWorldPosition","_camera","update","updateActionStates","clearFrameFlags","normalizeKey","code","preventDefault","updateKeyState","focus","updatePointerPosition","updatePointerButtonState","rect","getBoundingClientRect","clientX","left","clientY","top","framePressed","frameReleased","keyState","updateActionState","buttonState","inputState","actionState","anyPressed","mappedAction","normalized","replace","toLowerCase","space","enter","escape","tab","backspace","delete","home","end","pageup","pagedown","up","down","right","trim","test","trimmed","length","AudioManager","assets","currentMusic","masterVolume","unlocked","unlockPromise","handleUserInteraction","setupAutoUnlock","playSfx","id","volume","asset","type","audio","cloneNode","Math","max","min","remove","playPromise","play","catch","error","unlock","then","playMusic","loop","stopMusic","pause","currentTime","setMasterVolume","loadAssets","loadPromises","map","loadAsset","Promise","all","clear","removeAutoUnlock","isUnlocked","performUnlock","resolve","reject","Audio","preload","src","url","once","passive","silentAudio","LGFValidator","validate","cartridge","errors","warnings","validateStructure","validateSemantics","valid","push","path","message","Error","obj","suggestion","requiredProps","prop","allowedProps","join","undefined","version","metadata","theme","scenes","variables","validateVariables","validateAssets","validateScenes","validateTheme","validateMetadata","requiredFields","field","colors","requiredColors","color","isValidColor","font","isArray","sceneIds","scene","index","root","validateNode","node","validNodeTypes","transform","validateTransform","children","child","validateAction","validateTrigger","validateVector2","rotation","alpha","vector","value","validActionTypes","params","validTriggerEvents","assetType","Object","entries","totalSprites","sprites","validateCartridge","AssetManager","fonts","loadingPromises","defaultSprite","defaultFont","createDefaultAssets","manifest","options","onProgress","timeout","retryCount","allAssets","progress","loaded","failed","async","currentAsset","loadSpriteAsset","loadFontAsset","allSettled","existing","existingPromise","loadPromise","loadSpriteWithRetry","loadedAsset","loadFontWithRetry","getSprite","getFont","getSpriteWithFallback","sprite","image","createEmptyImage","getFontWithFallback","family","clearCache","getMemoryUsage","spriteMemory","width","height","fontMemory","isAssetLoaded","lastError","attempt","loadSpriteImage","setTimeout","pow","loadFontFace","img","Image","timeoutId","clearTimeout","onload","onerror","frames","crossOrigin","FontFace","fontFace","load","createElement","ctx","getContext","fillStyle","fillRect","toDataURL","CartridgeLoader","assetManager","audioManager","loadFromJSON","jsonString","validateOnly","skipAssets","stage","JSON","parse","validation","e","loadCartridgeAssets","assetProgress","assetTimeout","assetRetryCount","loadFromURL","response","fetch","ok","status","statusText","text","loadFromFile","file","reader","FileReader","target","result","readAsText","parsedCartridge","getAssetManager","getAudioManager","assetMemory","promises","AccessibilityManager","inputManager","ariaLiveRegion","focusIndicator","originalTheme","highContrastTheme","enableKeyboardNavigation","enableScreenReader","enableHighContrast","textScaling","enableFocusIndicators","announceStateChanges","currentFocus","focusableElements","isHighContrast","screenReaderEnabled","setupAccessibilityFeatures","setupCanvasAccessibility","setupKeyboardNavigation","setupScreenReaderSupport","setupFocusManagement","sceneNodes","updateFocusableElements","handleKeyboardNavigation","updateFocusIndicators","setTheme","createHighContrastTheme","applyHighContrastTheme","toggleHighContrast","announceToScreenReader","createDefaultTheme","setTextScaling","scale","round","getTextScaling","focusNode","nodeId","focusable","find","el","setFocus","getCurrentFocus","priority","setAttribute","textContent","getAccessibilityState","window","matchMedia","matches","canvasDescription","body","appendChild","overflow","border","borderRadius","pointerEvents","zIndex","display","nodes","collectFocusableElements","sort","a","b","aPos","getWorldTransform","bPos","isFocusable","element","createVirtualElement","ariaLabel","getAriaLabel","ariaRole","getAriaRole","isWorldVisible","visible","interactive","nodeData","label","focusNext","focusPrevious","focusFirst","focusLast","activateCurrentFocus","clearFocus","navigateDirection","nextIndex","getCurrentFocusIndex","currentIndex","prevIndex","direction","currentPos","bestCandidate","bestDistance","Infinity","pos","dx","dy","isInDirection","distance","sqrt","indexOf","canvasRect","screenX","screenY","primary","secondary","background","accent","sizes","fromEntries","spacing","radii","small","medium","large","LLMRTEngineImpl","accessibilityOptions","running","paused","currentScene","tickCount","frameRate","moduleRegistry","AudioManagerImpl","cartridgeLoader","accessibilityManager","loadCartridge","stringify","validateNodeTree","loadCartridgeFromJSON","loadCartridgeFromURL","loadCartridgeFromFile","start","stop","resume","getState","getInputManager","getCartridgeLoader","getAccessibilityManager","NodeImpl","parent","skew","addChild","isDescendantOf","removeChild","splice","removeFromParent","current","getRoot","getDepth","depth","parentWorld","DeterministicRNG","_seed","seed","abs","random","randomInt","floor","randomFloat","Mode7Math","screenToWorld","camera","viewport","horizon","normalizedX","horizonY","screenDistanceFromHorizon","tan","pitch","relativeX","relativeY","cos","sin","worldToScreen","worldX","worldY","rotatedX","rotatedY","getTextureCoordinates","worldPos","textureSize","offset","u","v","createDefaultCamera","PI","fov","Mode7RenderModule","textureCache","defaultCamera","render","context","mode7Node","mode7Data","getMode7Data","mode7Camera","getMode7Camera","texture","getTexture","renderPlaceholder","mode7Viewport","renderMode7Plane","data","textureWidth","textureHeight","textureId","gradient","createLinearGradient","addColorStop","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","imageData","createImageData","pixels","textureCanvas","textureCtx","drawImage","textureData","getImageData","renderScanline","putImageData","scanlineIndex","baseIndex","texCoords","sampleTexture","pixelIndex","r","g","Mode7ModuleDefinition","dependencies","ParticleSystem","emitter","maxParticles","particles","nextParticleId","emissionAccumulator","deltaTime","updateParticles","removeDeadParticles","enabled","spawnParticles","getParticles","startEmit","stopEmit","burstEmit","count","i","spawnParticle","updateEmitter","assign","particle","age","velocity","acceleration","rotationSpeed","lifetimeRatio","maxLifetime","alphaEnd","lerp","colorEnd","lerpColor","rate","lifetime","lifetimeVariance","velocityVariance","scaleVariance","t","startColor","endColor","ParticlesRenderModule","particleSystems","particlesNode","particleSystem","renderParticles","handleAction","oldCompositeOperation","globalCompositeOperation","blendMode","renderParticle","save","translate","rotate","globalAlpha","renderColoredParticle","restore","arc","fill","ParticlesModuleDefinition","tweens","timers","nextTweenId","nextTimerId","executeAction","conditions","evaluateConditions","executeGotoScene","executeSpawn","executeDespawn","executeSetVar","executeIncVar","executeRandomInt","executeIf","executeTween","executeStartTimer","executeStopTimer","executePlaySfx","executePlayMusic","executeStopMusic","updateTweens","updateTimers","every","condition","evaluateCondition","variable","sceneId","parentId","newNode","createNodeFromData","amount","gameLoop","getRNG","thenActions","elseActions","else","thenAction","elseAction","property","to","duration","easing","getEasingFunction","startValue","getPropertyValue","tweenId","tween","object","endValue","elapsed","timerId","timer","_context","_nodeData","parts","split","part","setPropertyValue","finalPart","completedTweens","easedProgress","currentValue","completedTimers","callbacks","tickRate","tickInterval","_running","_paused","_callbacks","_lastTime","_accumulator","_tickCount","_frameCount","_frameTimeHistory","_lastFpsUpdate","_currentFps","_droppedFrames","_rng","_rafHandle","_gameLoopStep","performance","now","frameTime","shift","maxAccumulator","droppedTime","droppedTicks","_tick","interpolation","_render","requestAnimationFrame","Date","_startTime","cancelAnimationFrame","setCallbacks","getMetrics","averageFrameTime","fps","droppedFrames","totalTicks","totalFrames","seedRNG","isRunning","isPaused","onTick","onRender","triggerSystem","previousKeyStates","previousPointerStates","checkKeyStateChanges","checkPointerStateChanges","setupDefaultMappings","keysToMonitor","wasPressed","isPressed","getActionForKey","inputEvent","handleInput","buttonsToMonitor","getActionForPointer","w","s","d","createGroup","createSprite","spriteId","createText","createButton","createCamera2D","zoom","nodeTypeToModule","qualitySettings","renderScale","particleDensity","shadowQuality","textureFiltering","postProcessing","audioQuality","maxActiveAudioSources","renderStats","drawCalls","triangles","renderTime","culledNodes","batchedSprites","spriteBatch","enableFrustumCulling","enableSpriteBatching","desynchronized","willReadFrequently","setupOffscreenCanvas","optimizeCanvasSettings","detectPlatformOptimizations","registerCoreRenderers","loadRegisteredModules","setupResponsiveCanvas","sceneTree","startTime","renderCtx","offscreenCtx","renderCanvas","offscreenCanvas","clearRect","setupCameraTransform","visibleNodes","cullNodes","renderOptimized","performanceMonitor","updateMetrics","setCamera","getViewport","screenPos","renderNode","worldTransform","getInterpolatedWorldTransform","applyTransform","coreRenderer","renderCoreNode","renderSprite","renderText","renderButton","fontSize","textAlign","textBaseline","fillText","padding","isFocused","textWidth","measureText","textHeight","buttonWidth","buttonHeight","radius","drawRoundedRect","setLineDash","strokeRoundedRect","quadraticCurveTo","closePath","registeredModules","moduleDefinition","updateViewport","container","parentElement","containerRect","devicePixelRatio","imageSmoothingEnabled","isMobile","navigator","userAgent","isLowEnd","detectLowEndDevice","maxBatchSize","memory","deviceMemory","cores","hardwareConcurrency","frustum","calculateFrustum","isNodeInFrustum","halfWidth","halfHeight","bottom","bounds","getNodeBounds","renderWithBatching","nonBatchableNodes","canBatchSprite","renderSpriteBatch","aSprite","bSprite","localeCompare","currentTexture","memoryManager","getCurrentMemoryUsage","usedJSHeapSize","setPerformanceMonitor","monitor","onQualityChange","settings","updateQualitySettings","setMemoryManager","manager","setAccessibilityManager","scaledWidth","scaledHeight","getRenderStats","optimizeForMobile","getPerformanceRecommendations","recommendations","stats","resize","nodeMap","buildNodeMap","addNode","findNode","addToNodeMap","removeNode","removed","removeFromNodeMap","findNodesByType","results","traverseNodes","getAllNodes","startNode","callback","getVisibleNodes","collectVisibleNodes","actionSystem","activeNodes","pointerStates","registerNode","startContext","processTriggers","unregisterNode","processTick","tickContext","handleKeyEvent","handlePointerEvent","processTimers","remaining","newRemaining","timerContext","eventData","startTimer","stopTimer","eventType","keyContext","triggerKey","getTriggerKey","isPointerOverNode","pointerContext","nodePos","isKeyPressed","isPointerPressed","clearInputStates","registry"],"mappings":"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"}